<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StudyWeb - Sergio Robla</title>
    <link
      rel="shortcut icon"
      href="../assets/icons/icon.png"
      type="image/x-icon"
    />
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body id="inicio">
    <header>
      <nav class="menu">
        <div class="logo">
          <a href="../index.html"
            ><img src="../assets/icons/icon.png" alt="logo"
          /></a>
        </div>
        <div class="enlaces">
          <a href="../about/regexp.html">RegExpğŸ§©</a>
          <a href="../about/git.html">GitğŸ±</a>
          <a href="../about/markdown.html">Markdownâœï¸</a>
          <a href="../about/hyperText.html">HtmlğŸŒ</a>
          <a href="../about/cascadeStyle.html">CssğŸ¨</a>
          <a href="../about/bootstrap.html">BootstrapğŸ…±ï¸</a>
          <a href="../about/javaScript.html">JavaScriptğŸ§ </a>
          <a href="../about/mySql.html">MySQLğŸ—ƒï¸</a>
          <a href="../about/studyJava.html">Javaâ˜•</a>
          <a href="../about/springBoot.html">Spring BootğŸš€</a>
          <a href="../about/react.html">Reactâš›ï¸</a>
        </div>
      </nav>
    </header>
    <main>
      <nav class="menu-page over">
        <ul>
          <li><a href="#inicio">MenÃºğŸ </a></li>
          <li><a href="#introduccion">IntroducciÃ³nğŸ”</a></li>
          <li><a href="#queson">Â¿QuÃ© son?ğŸ¤”</a></li>
          <li><a href="#historia">HistoriağŸ•°ï¸</a></li>
          <li><a href="#pqsirven">Â¿Para quÃ©?ğŸ¯</a></li>
          <li><a href="#ejemplo">BÃºsquedağŸ”</a></li>
          <li><a href="#motores">MotoresğŸš€</a></li>
          <li><a href="#patmat">PatternğŸ¯</a></li>
          <li><a href="#single">SingleğŸ•º</a></li>
          <li><a href="#estrella">EstrellağŸŒŸ</a></li>
          <li><a href="#congrup">ContenidoğŸ“¦</a></li>
          <li><a href="#nocongrup">No ContenidoğŸš«</a></li>
          <li><a href="#defrang">RangosğŸ“Š</a></li>
          <li><a href="#joker">JokerğŸƒ</a></li>
          <li><a href="#chacla">ClassesğŸ”¤</a></li>
          <li><a href="#decdig">DecimalğŸ’¹</a></li>
          <li><a href="#whitespace">EspacioğŸŒŒ</a></li>
          <li><a href="#word">Wordâœ¨</a></li>
          <li><a href="#carriage">CarriageğŸ›’</a></li>
          <li><a href="#quanti">QuantifiersğŸ</a></li>
          <li><a href="#short">Shorts Timesâ³</a></li>
          <li><a href="#exact">Exactly Timesâ±ï¸</a></li>
          <li><a href="#grla">Greedy - LazyğŸ¦¥</a></li>
          <li><a href="#anchors">Anchorsâš“</a></li>
          <li><a href="#stend">StringğŸ§µ</a></li>
          <li><a href="#wordbound">BuoundaryğŸ”</a></li>
          <li><a href="#alternation">Alternationâš¡</a></li>
          <li><a href="#gruprarus">RarosğŸ¸</a></li>
          <li><a href="#webrecom">WebsğŸ¤“</a></li>
        </ul>
      </nav>
      <article class="content">
        <h1 class="main-title">ğŸ”Regular ExpressionğŸ§©</h1>
        <div>
          <p>
            Las Expresiones Regulares, comÃºnmente conocidas como Regex, son una
            herramienta poderosa para trabajar con texto. Son patrones que
            permiten buscar, reemplazar, y manipular cadenas de caracteres con
            gran precisiÃ³n y flexibilidad. Las regex se utilizan en la
            programaciÃ³n y en herramientas de procesamiento de texto para
            realizar tareas complejas de bÃºsqueda y ediciÃ³n de forma eficiente.
          </p>
          <p>
            Por ejemplo, una expresiÃ³n regular puede ser utilizada para validar
            el formato de un correo electrÃ³nico, asegurÃ¡ndose de que cumpla con
            un patrÃ³n estÃ¡ndar como usuario@dominio.com. La regex para esta
            tarea podrÃ­a ser algo asÃ­ como
            ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$, donde cada parte
            del patrÃ³n define un aspecto especÃ­fico de lo que se considera un
            correo electrÃ³nico vÃ¡lido.
          </p>
          <p>
            Otro uso comÃºn de las regex es la bÃºsqueda de patrones dentro de un
            texto, como identificar todas las fechas en un formato especÃ­fico
            dentro de un documento. Por ejemplo, para encontrar fechas en el
            formato dd/mm/aaaa, podrÃ­amos usar la regex \b\d{2}/\d{2}/\d{4}\b,
            que busca secuencias de dos dÃ­gitos, seguidas de una barra, otros
            dos dÃ­gitos, otra barra, y finalmente cuatro dÃ­gitos.
          </p>
          <p>
            Las regex tambiÃ©n son Ãºtiles para dividir texto en tokens o
            segmentos, como separar palabras o frases en un pÃ¡rrafo. Por
            ejemplo, para dividir un texto por espacios y puntuaciÃ³n podrÃ­amos
            usar una regex como [\s,.]+, que identifica espacios, comas y puntos
            como delimitadores.
          </p>
          <p>
            En resumen, las Expresiones Regulares son una herramienta esencial
            para cualquier persona que trabaje con texto, ya que proporcionan un
            mÃ©todo poderoso y versÃ¡til para realizar bÃºsquedas y ediciones
            complejas en cadenas de caracteres.
          </p>
        </div>
      </article>
      <article class="content">
        <section>
          <h2 id="introduccion">
            1. IntroducciÃ³n a las expresiones regulares ğŸ”
          </h2>
          <h3 id="queson">1.1 - Â¿QuÃ© son las expresiones regulares? ğŸ¤”</h3>
          <p>
            El tÃ©rmino de expresiones regulares nace a partir del tÃ©rmino inglÃ©s
            Regular Expressions, del que tambiÃ©n surgen varias abreviaturas como
            RegEx (de REGular EXpressions) o RegExp (de REGular EXPressions).
          </p>
          <p class="recuadro">
            ğŸ§  Las expresiones regulares (RegEx), no son un lenguaje de
            programaciÃ³n, sino una serie de sÃ­mbolos (expresiones o patrones)
            que nos permitirÃ¡n definir patrones de bÃºsqueda en cadenas de texto.
          </p>
          <p>
            Por tanto, no son nada mÃ¡s y nada menos que una "especie de
            lenguaje" para manipular/realizar bÃºsquedas sobre los archivos de
            texto o simplemente sobre textos sin la necesidad de que estos estÃ©n
            contenidos en el interior de un fichero.
          </p>
        </section>
        <section>
          <h3 id="historia">
            1.2 - Historia y origen de las expresiones regulares ğŸ•°ï¸
          </h3>
          <h4>Avances hasta la dÃ©cada de los 40 ğŸ“œ</h4>
          <p>
            La historia de las expresiones regulares se remonta a la dÃ©cada de
            1940 y estÃ¡ estrechamente relacionada con los avances en la lÃ³gica
            matemÃ¡tica y la teorÃ­a de la computaciÃ³n.
          </p>
          <p class="recuadro">
            ğŸ¤– El desarrollo de las expresiones regulares se basÃ³ en
            investigaciones previas sobre autÃ³matas finitos y la formulaciÃ³n de
            lenguajes formales. Durante la dÃ©cada de 1930 y 1940, varios
            matemÃ¡ticos y lÃ³gicos, incluyendo a Alonzo Church, Alan Turing, Emil
            Post y otros, estaban explorando los conceptos fundamentales de la
            teorÃ­a de la computaciÃ³n y la lÃ³gica matemÃ¡tica.
          </p>
          <h4>Pitts & McCulloch: creando la neurona de McCulloch - Pitts ğŸ§ </h4>
          <p>
            El origen o los inicios de la creaciÃ³n de las expresiones regulres,
            tiene su origen en la neurociencia y no en la ciencia de la
            informÃ¡tica. Concretamente en 1943, en el estudio realizado por los
            padres de la neurona de Pitts & McCulloch.
          </p>
          <p>
            Esta investigaciÃ³n fue plasmada en el documento "<a
              href="../docs/mccolloch.logical.calculus.ideas.1943.pdf"
              target="_blank"
              >A Logical calculus of the ideas immanent in nervous activity</a
            >" .
          </p>
          <p>
            Los avances realizados en este estudio fueron utilizados a
            posteriori dentro del campo de la informÃ¡tica para en la
            idealizaciÃ³n de las expresiones regulares.
          </p>
          <h4>Kleene la "estrella" del regex ğŸŒŸ</h4>
          <p>
            En la dÃ©cada de 1950, el matemÃ¡tico y lÃ³gico estadounidense Stephen
            Cole Kleene introdujo el tÃ©rmino "expresiÃ³n regular" por primera vez
            dentro de su trabajo de investigaciÃ³n llamado "<a
              href="../docs/RM704.pdf"
              target="_blank"
              >Representation of events in nerve nets and finite automata</a
            >" en la que refleja sus investigaciones en teorÃ­a de autÃ³matas y
            lenguajes formales.
          </p>
          <p class="recuadro">
            ğŸ¤– Cuando hablamos de teoeÃ­a de autÃ³matas, nos referimos a la rama
            de la informÃ¡tica teÃ³rica y las matemÃ¡ticas que se centran en el
            estudio de modelos abstractos de mÃ¡quinas o dispositivos que pueden
            realizar ciertas operaciones sobre cadenas de sÃ­mbolos. La teorÃ­a de
            lenguajes formales estudia patrones de cadenas de sÃ­mbolos y sus
            propiedades mediante gramÃ¡ticas y autÃ³matas, siendo fundamental en
            la comprensiÃ³n y anÃ¡lisis de lenguajes de programaciÃ³n,
            procesamiento de texto y verificaciÃ³n de software.
          </p>
          <p>
            Si nos fijamos, en la primera lÃ­nea podemos ver que el proyecto se
            llama RAND y fue encargado por la U.S. AIR FORCE.
          </p>
          <p>
            Las expresiones regulares son patrones textuales que describen
            conjuntos de cadenas de caracteres. Permiten la descripciÃ³n y
            manipulaciÃ³n de lenguajes regulares, que son un tipo de lenguaje
            formal en la teorÃ­a de lenguajes formales.
          </p>
          <p>
            Estas expresiones se utilizan en muchos contextos, incluyendo la
            bÃºsqueda y manipulaciÃ³n de texto en editores de texto, procesamiento
            de cadenas en programaciÃ³n, y en el diseÃ±o de motores de bÃºsqueda y
            sistemas de filtrado de informaciÃ³n.
          </p>
          <p>
            Kleene formalizÃ³ las expresiones regulares utilizando notaciÃ³n
            matemÃ¡tica y desarrollÃ³ mÃ©todos para analizar y generar patrones de
            texto utilizando estas expresiones.
          </p>
          <p>
            Para ello, utilizÃ³ sÃ­mbolos como "*" para denotar repeticiÃ³n y "+"
            para denotar al menos una repeticiÃ³n de un sÃ­mbolo o grupo de
            sÃ­mbolos en una expresiÃ³n.
          </p>
          <p>
            Estos sÃ­mbolos y la notaciÃ³n matemÃ¡tica que desarrollÃ³ permitieron
            describir patrones de manera mÃ¡s concisa y precisa.
          </p>
          <p class="recuadro">
            ğŸ¤– Con el tiempo, las expresiones regulares se convirtieron en un
            componente esencial en la programaciÃ³n y la manipulaciÃ³n de texto en
            sistemas informÃ¡ticos. Se incorporaron en varios lenguajes de
            programaciÃ³n y herramientas, lo que permitiÃ³ a los desarrolladores
            realizar tareas de bÃºsqueda, extracciÃ³n y manipulaciÃ³n de patrones
            de manera mÃ¡s eficiente. Desde entonces, las expresiones regulares
            han evolucionado y se han vuelto ubicuas en la informÃ¡tica y el
            procesamiento de datos.
          </p>
          <h4>Ken Thompson, finalmente implementa ğŸ’»</h4>
          <p>
            Durante los aÃ±os 60, Ken Thompson, un cientÃ­fico de la computaciÃ³n
            que destaca por ser uno de los creadores del sistema operativo Unix,
            tuvo un papel muy significativo en la evoluciÃ³n y popularizaciÃ³n de
            las expresiones regulares en el Ã¡mbito de la informÃ¡tica.
          </p>
          <p>
            Aunque Stephen Cole Kleene introdujo el concepto de expresiones
            regulares en la teorÃ­a matemÃ¡tica, Ken Thompson fue quien llevÃ³
            estas ideas a la prÃ¡ctica y las integrÃ³ en el mundo de la
            programaciÃ³n y la informÃ¡tica prÃ¡ctica.
          </p>
          <p>
            Thompson implementÃ³ las expresiones regulares dentro de un editor de
            texto llamado â€œEDâ€ lo que permitÃ­a a los usuarios realizar
            operaciones con la finalidad de que los usuarios pudieran realizar
            ciertas operaciones de ediciÃ³n de texto utilizando expresiones
            regulares.
          </p>
          <p>
            AquÃ­ podemos ver el artÃ­culo "<a
              href="../docs/Thompson-1968.pdf"
              target="_blank"
              >Regular Expression Search</a
            >" escrito por el mismo Thompson para Bell Telephone Laboratories,
            en el que detalla aspectos sobre el algoritmo que utilizÃ³ para
            implementar las expresiones regulares dentro del editor de texto EQ.
          </p>
          <p class="recuadro">
            ğŸ¤– Thompson realiza el hito que representa el punto de entrada de
            las expresiones regulares RegEx dentro de la informÃ¡tica.
          </p>
          <p class="recuadro">
            ğŸ“ Posteriormente, Thompson trabajando junto con Dennis Ritchie,
            desarrollaron el lenguaje de programaciÃ³n "grep" (que significa
            "global regular expression print"), que permitÃ­a buscar patrones en
            archivos y mostrar las lÃ­neas que coincidÃ­an con esas expresiones
            regulares. La utilidad "grep" se convirtiÃ³ en una herramienta
            esencial en Unix y otros sistemas operativos basados en Unix.
          </p>
          <p>
            Aunque las expresiones regulares han evolucionado a lo largo del
            tiempo, y en algunos aspectos nada tiene que ver con las de aquel
            entonces, tal y como podÃ©is observar en el siguiente
            <a href="../docs/qedman.pdf" target="_blank"
              >memorando escrito para Bells Labs en 1970</a
            >
            , algunas de las caracterÃ­sticas de expresiones regulares de QED se
            siguen manteniendo a dÃ­a de hoy despuÃ©s de tantos aÃ±os.
          </p>
          <h4>
            Larry Wall implementa las expresiones por primera vez dentro de Perl
            ğŸ’¡
          </h4>
          <p>
            Larry Wall, el creador del lenguaje Perl, introdujo expresiones
            regulares dentro del lenguaje.
          </p>
          <p>
            Consiguiendo que las expresiones regulares fueran fÃ¡ciles de usar y
            agregando caracterÃ­sticas avanzadas como remplazos y capturas.
            TambiÃ©n popularizÃ³ conceptos como "greediness" en las coincidencias.
          </p>
          <p class="recuadro">
            ğŸ“Œ Sus contribuciones influyeron en cÃ³mo se usan las expresiones
            regulares en la programaciÃ³n.
          </p>
          <img
            src="../images/regexp/padres de regex.png"
            id="img-parentsregex"
            alt="Padres de regex"
          />
        </section>
        <section>
          <h3 id="pqsirven">
            1.3 - Â¿Para quÃ© sirven las expresiones regulares? ğŸ¯
          </h3>
          <p>
            Las expresiones regulares son extremadamente Ãºtiles en determinadas
            situaciones donde necesitas realizar tareas de bÃºsqueda y
            manipulaciÃ³n de texto de manera avanzada.
          </p>
          <p>
            Algunos casos tÃ­picos en los que se utilizan expresiones regulares
            son:
          </p>
          <ol>
            <li>
              BÃºsqueda de patrones: Puedes buscar palabras especÃ­ficas, nÃºmeros,
              fechas o cualquier patrÃ³n de caracteres en un texto de manera mÃ¡s
              flexible y eficiente que con una simple bÃºsqueda de texto.
            </li>
            <li>
              ValidaciÃ³n de datos: Puedes validar si una cadena cumple con un
              formato especÃ­fico, como un nÃºmero de telÃ©fono, direcciÃ³n de
              correo electrÃ³nico, cÃ³digo postal, etc.
            </li>
            <li>
              ExtracciÃ³n de informaciÃ³n: Puedes extraer partes especÃ­ficas de
              una cadena que cumplan con un patrÃ³n determinado, como obtener
              todos los enlaces de una pÃ¡gina web o extraer datos estructurados
              de un texto.
            </li>
            <li>
              Reemplazo y manipulaciÃ³n de texto: Puedes realizar operaciones de
              reemplazo, eliminaciÃ³n o modificaciÃ³n de texto basado en patrones
              especÃ­ficos.
            </li>
          </ol>
          <p>Algunos ejemplos de todo esto podrÃ­an ser:</p>
          <ul>
            <li>
              El proceso de validar si un email tiene un formato correcto o no.
            </li>
            <li>
              Substituir cierta informaciÃ³n dentro de un documento/archivo.
            </li>
            <li>
              Realizar una modificaciÃ³n masiva sobre mÃºltiples INSERTs de SQL.
            </li>
          </ul>
        </section>
        <section>
          <h3 id="ejemplo">
            1.4 - Ejemplo de bÃºsqueda de patrones con el comando grep y regexp
            ğŸ”
          </h3>
          <p>
            Una vez aterrizados en la historia y en las expresiones regulares,
            vamos a ver un pequeÃ±o ejemplo de cÃ³mo trabajar con ellas mediante
            al comando grep solamente disponible dentro de los sistemas
            operativos que estÃ¡n basados en UNIX.
          </p>
          <h4>Â¿QuÃ© es GREP? Â¿Para quÃ© se utiliza? ğŸ’»</h4>
          <p>
            GREP es un comando de terminal que nos permite realizar bÃºsquedas
            globales.
          </p>
          <p>
            GREP es el acrÃ³nimo de Global Regular Expression Print el
            significado de estas siglas es el siguiente:
          </p>
          <ul>
            <li>G ğŸ¡¢ Global</li>
            <li>RE ğŸ¡¢ Regular Expressions</li>
            <li>P ğŸ¡¢ Print</li>
          </ul>
          <p>
            Con GREP, por tanto, vamos a realizar una bÃºsqueda Global, es decir,
            sobre una serie de documentos situados en un directorio y finalmente
            vamos a hacer un Print (impresiÃ³n) de todas las lÃ­neas coincidentes
            mediante a una Regular Expresion.
          </p>
          <p class="recuadro">
            ğŸ” GREP destaca por ser un marcar un antes y un despuÃ©s, un gran
            paso en cÃ³mo realizar bÃºsquedas en Unix.
          </p>
          <h4>Trabajando desde la web una terminal UNIX ğŸŒ</h4>
          <p>
            Para realizar dicha prueba, vamos a trabajar desde una emulaciÃ³n web
            de un sistema UNIX.
          </p>
          <p>
            Para ello, entramos en la siguiente web:
            <a href="https://bellard.org/jslinux/" target="_blank"
              >Entra en la web.</a
            >
          </p>
          <p>
            Una vez dentro, seleccionamos el sistema operativo con el que
            queremos trabajar en mi caso usarÃ© la siguiente versiÃ³n:
          </p>
          <img
            src="../images/regexp/terminal UNIX.png"
            id="img-linuxandother"
            alt="Linux or other operating systems"
          />
          <p>
            Una vez dentro, como podrÃ©is observar, se nos abrirÃ¡ una terminal de
            Linux en el propio browser desde el que podremos ejecutar los
            comandos pertinentes:
          </p>
          <img
            src="../images/regexp/comandos UNIX.png"
            id="img-comandosUnix"
            alt="Comandos UNIX"
          />
          <h4>Creando el fichero a buscar ğŸ“‚</h4>
          <p>
            Primeramente, vamos a hacer un ls (de list) para listar todos los
            ficheros actuales:
          </p>
          <img src="../images/regexp/ls.png" id="img-ls" alt="" />
          <p>
            Posteriormente, creamos un fichero mediante el comando cat de la
            siguiente manera:
          </p>
          <p>Escribimos ğŸ¡¢ cat > (nombre del fichero)</p>
          <p>
            En su interior, vamos a escribir el contenido sobre el que
            realizaremos la bÃºsqueda con GREP.
          </p>
          <p>
            Para salir del documento si queremos guardar los cambios utilizamos
            Ctrl + D, o si quisiÃ©ramos salir sin guardar el documento Ctrl + C.
          </p>
          <p>
            Finalmente, una vez guardado el fichero, vamos a hacer un ls para
            mostrar si hemos creado el fichero correctamente.
          </p>
          <p>
            Si ejecutamos el comando tail junto al nombre del fichero que
            acabamos de crear, podemos mostrar el contenido del fichero que
            acabamos de introducir en el paso anterior:
          </p>
          <img src="../images/regexp/ls tail.png" id="img-lstail" alt="" />
          <img src="../images/regexp/tail.png" id="img-tail" alt="" />
          <h4>Ejemplo de uso de GREP ğŸ“‹</h4>
          <p>
            Primer Ejemplo, finalmente, vamos a realizar la primera bÃºsqueda de
            la expresiÃ³n regexp mÃ¡s sencilla de todas, una palabra sin mÃ¡s. Para
            ello, tenemos que utilizar el comando grep junto a la expresiÃ³n
            regular que vamos a buscar, en este caso la palabra David
            entrecomillada. E inmediatamente despuÃ©s, la ruta sobre la que
            queremos realizar la bÃºsqueda.
          </p>
          <p class="recuadro">
            ğŸ“„ Para realizar una bÃºsqueda global, es decir, sobre todos los
            directorios utilizamos *
          </p>
          <p>
            Si realizamos la bÃºsqueda con todos los caracteres en minÃºsculas,
            fijaros que la consola no imprimirÃ¡ ningÃºn resultado:
          </p>
          <img src="../images/regexp/grep1.png" id="img-grep1" alt="" />
          <p>
            En cambio, si repetimos la misma operaciÃ³n con el nombre con la D en
            mayÃºscula, ahora si que podemos observar que nos devuelve el
            resultado correctamente:
          </p>
          <img src="../images/regexp/grep2.png" id="img-grep2" alt="" />
          <p>
            Segundo Ejemplo, si queremos que la bÃºsqueda no sea case-sensitive,
            es decir, a mayÃºsculas y minÃºsculas podemos aÃ±adir el flag (la
            bandera) -i. Vamos a verlo:
          </p>
          <img src="../images/regexp/grep3.png" id="img-grep3" alt="" />
          <p>
            Tercer Ejemplo, Si quisiÃ©ramos buscar los ficheros que empiecen por
            Hola, harÃ­amos lo siguiente:
          </p>
          <img src="../images/regexp/grep4.png" id="img-grep4" alt="" />
          <p>
            Cuarto Ejemplo, Si quisiÃ©ramos buscar los ficheros que acaben por D
            harÃ­amos lo siguiente:
          </p>
          <img src="../images/regexp/grep5.png" id="img-grep5" alt="" />
        </section>
        <section>
          <h3 id="motores">
            1.5 - Â¿QuÃ© son los motores de ejecuciÃ³n de regexp? Y tipos engines
            de regexp ğŸš€
          </h3>
          <h4>Â¿QuÃ© son los motores de expresiones regulares? ğŸ§©</h4>
          <p>
            Los motores (engines) de expresiones regulares, son programas o
            bibliotecas que implementan la capacidad de realizar procesamiento e
            interpretaciÃ³n de patrones de expresiones regulares.
          </p>
          <p>
            Estos modelos permiten buscar, comparar y manipular texto basÃ¡ndose
            en patrones definidos por las expresiones regulares.
          </p>
          <h4>Distintos motores de expresiones regulares ğŸ§°</h4>
          <p>
            Los motores de expresiones regulares se encuentran tanto en
            lenguajes de programaciÃ³n (como Java, Python, JavaScript, Perl, PHP,
            .NET, etc.) como herramientas de software (Eclipse, Visual Studio
            Code, etc.) e incluso en sistemas operativos.
          </p>
          <p class="recuadro">
            ğŸ”§ Cada motor puede tener su propia sintaxis y caracterÃ­sticas
            especÃ­ficas para expresiones regulares, pero la idea general es la
            misma: utilizar patrones para realizar operaciones complejas en
            cadenas de texto.
          </p>
          <p>
            Algunos de los principales motores para ejecutar expresiones
            regulares son:
          </p>
          <ol>
            <li>
              Oniguruma ğŸ¡¢ Es un motor de expresiones regulares ampliamente
              utilizado que se encuentra en Visual Studio Code, TextMate, Ruby,
              PHP y otros. <br />
              Es conocido por su soporte completo de expresiones regulares con
              muchas caracterÃ­sticas y extensiones.
            </li>
            <li>
              Java (java.util.regexp) ğŸ¡¢ Proporciona java.util.regex, un
              paquete/librerÃ­a que contiene un conjunto de clases que nos va a
              proporcionar un motor de expresiones regulares para trabajar con
              expresiones regulares dentro de Java. Entre las clases mÃ¡s
              utilizadas se encuentra Pattern y Matcher.
              <br />
              Estas clases permiten compilar expresiones regulares, buscar
              coincidencias y realizar operaciones de reemplazo en cadenas.
            </li>
            <li>
              JavaScript (Regexp) ğŸ¡¢ Los navegadores y Node.js utilizan el motor
              de expresiones regulares incorporado en JavaScript, que se accede
              a travÃ©s de la clase RegExp. Por lo que podemos utilizar
              expresiones regulares de forma nativa en JavaScript para realizar
              bÃºsquedas y reemplazos en cadenas de texto.
            </li>
            <li>
              GNU Grep (grep) ğŸ¡¢ grep es una herramienta de lÃ­nea de comandos
              disponible en sistemas Unix como por ejemplo Linux, que nos
              permite realizar bÃºsquedas de patrones utilizando expresiones
              regulares.
            </li>
            <li>
              PCRE (Perl Compatible Regular Expressions) ğŸ¡¢ PCRE es un motor de
              expresiones regulares compatible con Perl, que ademÃ¡s se utiliza
              en lenguajes como PHP, Python (a travÃ©s del mÃ³dulo re), y otros.
              Ofrece una amplia gama de funcionalidades, incluyendo expresiones
              regulares recursivas.
            </li>
            <li>
              PHP (PCRE) ğŸ¡¢ PHP utiliza el motor PCRE para su soporte de
              expresiones regulares. Puedes utilizar la funciÃ³n preg_match() y
              otras funciones relacionadas para trabajar con expresiones
              regulares.
            </li>
            <li>
              Ruby (Regexp) ğŸ¡¢ Ruby proporciona soporte nativo para expresiones
              regulares a travÃ©s de la clase Regexp.
            </li>
            <li>
              C# (.NET Regex) ğŸ¡¢ C# proporciona soporte para expresiones
              regulares a travÃ©s de la clase System Text RegularExpressions
              Regex.
            </li>
            <li>
              Python (re) ğŸ¡¢ Python incluye un mÃ³dulo llamado re que ofrece
              soporte para expresiones regulares. Este mÃ³dulo proporciona
              funciones para trabajar con expresiones regulares que nos
              permitirÃ¡n compilar expresiones regexp, buscar coincidencias y
              realizar cambios de manera similar a Java.
            </li>
          </ol>
          <p class="recuadro">
            â„¹ Estos son solo algunos ejemplos de los motores de expresiones
            regulares disponibles en diferentes lenguajes y herramientas. Cada
            uno de ellos puede tener diferencias en la sintaxis o en las
            caracterÃ­sticas admitidas, pero todos estÃ¡n diseÃ±ados para
            proporcionar una forma poderosa de realizar operaciones avanzadas de
            bÃºsqueda y manipulaciÃ³n de texto basadas en patrones.
          </p>
          <h3 id="patmat">1.6 - Â¿QuÃ© es el patrÃ³n/pattern y el match? ğŸ¯</h3>
          <h4>Â¿QuÃ© es el patrÃ³n, pattern? ğŸ§©</h4>
          <p>
            Cuando hablamos de patrÃ³n o de pattern, dentro del contexto de las
            expresiones regulares, es a la expresiÃ³n, es decir, la secuencia de
            caracteres mediante la cual intentaremos realizar un match dentro de
            un fichero gracias a un motor de expresiones regulares.
          </p>
          <p class="recuadro">
            ğŸ§ Cada carÃ¡cter definido dentro del patrÃ³n representa una
            instrucciÃ³n para buscar cierto tipo de contenido en el texto. Por
            tanto, el patrÃ³n no es nada mÃ¡s que una combinaciÃ³n de caracteres
            literales y caracteres especiales que tienen ciertos significados
            especÃ­ficos. Los cuales formarÃ¡n la expresiÃ³n regular a partir de la
            cual buscaremos las coincidencias (matchings) dentro de un texto.
            Dicho patrÃ³n que buscarÃ¡ si una determinada expresiÃ³n regular existe
            dentro de un determinado texto.
          </p>
          <h4>Â¿QuÃ© es el match (coincidencia)? âœ…</h4>
          <p>
            En el contexto de las expresiones regulares un match, se refiere a
            cada una de las instancias o coincidencias encontradas dentro del
            texto que cumple con lo definido dentro del patrÃ³n de la expresiÃ³n
            regular.
          </p>
          <p>
            En otras palabras, cuando aplicas una expresiÃ³n regular, es decir,
            un patrÃ³n generando una cadena de texto, y esa cadena de texto
            buscarÃ¡ en el interior de un texto de tal forma que, cada resultado
            encontrado serÃ¡ una coincidencia o un "match".
          </p>
          <p class="recuadro">
            ğŸ“Œ^\d{3} ğŸ¡¢ Este patrÃ³n significa que selecciona todas las lÃ­neas que
            empiecen por 3 dÃ­gitos.
          </p>
          <p>
            En resumen, el patrÃ³n en una expresiÃ³n regular define cÃ³mo se busca
            o manipula el texto. Contiene una serie de caracteres que
            representan reglas especÃ­ficas para encontrar patrones particulares
            en las cadenas de texto.
          </p>
          <h4>Instalando plugins para VSC âš™ï¸</h4>
          <p>
            Existen determinadas expresiones regulares que pueden llegar a ser
            muy complejas y cuya lectura puede ser todo un reto.
          </p>
          <p>
            Un ejemplo de ello es General Email Regex (RFC 5322 Official
            Standard) la cual nos permite realizar la validaciÃ³n de un email con
            un 99,99% de eficiencia:
          </p>
          <p>
            >(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"
            (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b
            \x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:
            [a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
            (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\
            x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
          </p>
          <p>
            Si tenemos que interpretar dicha expresiÃ³n sin ayuda alguna, esto
            serÃ­a una tarea muy muy muy compleja.
          </p>
          <p>
            Por ello, tenemos determinadas web y plugins que nos permiten
            simplificar en media de lo posible determinadas tareas con regexp.
            Un ejemplo de ello es la siguiente web:
            <a href="https://jex.im/regulex/" target="_blank">Enlace de web</a>
          </p>
          <p class="recuadro">
            ğŸ— Si pegamos el cÃ³digo de la expresiÃ³n regular podemos generar un
            esquema que nos permitirÃ¡ entender que hace la expresiÃ³n.
          </p>
          <img src="../images/regexp/img jex.png" id="img-jex" alt="" />
        </section>
      </article>
      <article class="content">
        <section>
          <h2 id="single">2. Single Characters ğŸ”¡</h2>
          <h3 id="estrella">2.1 - La estrella de Kleene * ğŸŒŸ</h3>
          <h4>
            Â¿QuÃ© es la estrella de Kleene dentro de las expresiones regulares?
            ğŸŒŸ
          </h4>
          <p>
            La estrella de Kleene (*) es el meta carÃ¡cter mÃ¡s potente de todos
            con el que la comunidad trata de homenajear de Kleene al que en
            general consideran â€œel padreâ€ de las expresiones regulares.
          </p>
          <p class="recuadro">
            ğŸ“Œ Por el momento solamente vamos a ver solamente uno de sus usos.
            Aunque me gustarÃ­a matizar que con la estrella de Kleene podemos
            realizar tambiÃ©n otras funcionalidades que ya veremos cuando
            lleguemos a dicho apartado.
          </p>
          <p>
            /* ğŸ¡¢ Seleccionamos cualquier carÃ¡cter (incluido el salto de lÃ­nea
            \n)
          </p>
          <h4>Saltos de lÃ­nea en regexp â†µ</h4>
          <p>
            Para poder visualizarlos, podemos ayudarnos de regexp. Para ello,
            realizamos un \n podemos matchear todos los saltos de lÃ­nea que hay
            en nuestro documento.
          </p>
          <p class="recuadro">
            ğŸ“Œ Los saltos de lÃ­nea no se pueden visualizar a golpe de ojo dentro
            de un documento.
          </p>
          <h4>Espacios en regexp ã€°ï¸</h4>
          <p class="recuadro">
            ğŸ“Œ Los saltos de lÃ­nea los podemos visualizar, detectar o
            identificar fÃ¡cilmente dentro de un documento por la separaciÃ³n de
            los caracteres.
          </p>
          <p>
            AdemÃ¡s de ello, si seleccionamos el texto al completo en el interior
            del IDE (Visual Studio Code), podemos observar como aparece una
            especie de puntito Â· el cual representa cada uno de los espacios.
          </p>
          <p>
            Si utilizamos \s o en su defecto escribimos un espacio sin nada mÃ¡s,
            podemos ver que hacemos un match de todos los espacios del
            documento.
          </p>
          <h4>Ejemplo de un uso de la estrella de Kleene ğŸŒ </h4>
          <p>
            En cambio, si utilizamos la estrella de Kleene, podemos ver que se
            seleccionan todos los caracteres inclusive los saltos de lÃ­nea y
            espacios.
          </p>
          <p class="recuadro">
            ğŸ“Œ Por ello, decimos que la estrella de Kleene es el meta carÃ¡cter
            mÃ¡s poderoso de todos, engloba todo incluso los saltos de lÃ­nea o
            espacios.
          </p>
        </section>
        <section>
          <h3 id="congrup">2.2 - [set] Contenido en el grupo ğŸ”£</h3>
          <p>
            En esta secciÃ³n vamos a empezar a aprender como trabajar con grupos
            de caracteres ademÃ¡s de explicar que diferencias hay entre patrÃ³n
            este tipo de grupos y los caracteres literales. Â¡Vamos a ello!
          </p>
          <p class="recuadro">
            ğŸ“Œ [carÃ¡cter/es] buscarÃ¡ cualquier carÃ¡cter incluido entre los []. A
            diferencia de los caracteres literales anteriores, con esta manera
            matchearÃ¡ todo lo contenido en el interior del parÃ©ntesis
            independientemente de que estÃ©n definidos consecutivamente o no.
          </p>
        </section>
        <section>
          <h3 id="nocongrup">2.3 - [^set] No contenido en el grupo ğŸš«</h3>
          <p>
            [^carÃ¡cter/es] realizarÃ¡ el match de cualquier carÃ¡cter que NO estÃ©
            incluido dentro de los corchetes [] independiente de si es
            consecutivo o si no.
          </p>
        </section>
        <section>
          <h3 id="defrang">
            2.4 - [set] [^set] Definiendo conjuntos/rangos ğŸ²
          </h3>
          <h4>
            Seleccionando un conjunto de letras (abecedario al completo) ğŸ”¤
          </h4>
          <p>
            De la misma forma que podemos definir un rango mediante a una
            secuencia de caracteres literales, podemos realizarlo mediante a un
            rango/conjunto de la siguiente manera:
          </p>
          <p>
            [a-z] Nos permite definir un rango especÃ­fico dentro del patrÃ³n.
          </p>
          <p class="recuadro">
            ğŸš¨ A excepciÃ³n de la Ã± tanto en mayÃºscula como minÃºscula ya que la
            informÃ¡tica por decirlo asÃ­ â€œestÃ¡ hecha en inglÃ©sâ€ y la Ã± no existe
            en dicho lenguaje.
          </p>
          <h4>AÃ±adiendo caracteres a un conjunto â•</h4>
          <p>
            Si queremos que dicho rango aÃ±ada la Ã± tambiÃ©n deberemos de aÃ±adirla
            al conjunto de la siguiente manera [a-zÃ±].
          </p>
          <h4>Upper & Lower case range ğŸ” </h4>
          <p>
            Las expresiones regulares pueden ser "case sensitive" o "case
            insensitive", lo que significa que pueden o no distinguir entre
            letras mayÃºsculas y minÃºsculas en el texto que se estÃ¡ analizando.
          </p>
          <h4>Seleccionando un rango numÃ©rico ğŸ”¢</h4>
          <p>[0-9] TambiÃ©n podemos utilizar rangos de numÃ©ricos.</p>
          <h4>Rango de caracteres â€œespecialesâ€ ğŸ”£</h4>
          <p>
            [Ã€-Ã¿] Otro ejemplo de como seleccionar los caracteres especiales
            (acentuados, dieresis, eÃ±esâ€¦), es decir, que no son utilizados en el
            lenguaje inglÃ©s.
          </p>
        </section>
        <section>
          <h3 id="joker">2.5 - Uso del meta carÃ¡cter joker, .* & \char ğŸƒ</h3>
          <h4>Uso del meta carÃ¡cter . â€œel famoso jokerâ€ ğŸƒ</h4>
          <p>
            . meta carÃ¡cter tambiÃ©n conocido como el â€œjokerâ€, selecciona
            cualquier carÃ¡cter, de una forma similar a â€œun comodÃ­nâ€ Â¡A excepciÃ³n
            de los saltos de lÃ­nea! Por lo que poder decirlo asÃ­ es casi igual
            de poderoso que la estrella de Kleene. Decimos Â¡Casi! ya que es un
            poquitÃ­n menos potente.
          </p>
          <p>
            El primer uso que podrÃ­amos con . serÃ­a el de seleccionar todos los
            caracteres del documento.
          </p>
          <h4>Doble jocker ğŸƒğŸƒ</h4>
          <p>
            ..carÃ¡cter/es ğŸ¡¢ Otro uso para el meta carÃ¡cter . es el de aÃ±adir
            varios puntos a la vez ..
          </p>
          <h4>Joker & Kleene ğŸƒâ­</h4>
          <p>
            .* ğŸ¡¢ TambiÃ©n es habitual utilizarlo para seleccionar varios
            caracteres combinado con la famosa estrella de Kleene *.
          </p>
          <p>
            Este patrÃ³n serÃ¡ muy Ãºtil para seleccionar una parte determinada en
            un texto. Por ejemplo, hasta el final de la lÃ­nea para
            posteriormente reemplazar dicho contenido.
          </p>
          <h4>
            Seleccionando meta caracteres utilizados en las expresiones
            regulares ğŸ”¤
          </h4>
          <p>
            \char Existen determinados caracteres como por ejemplo: *,.+ entre
            otros que debido a que tienen algÃºn significado dentro del lenguaje
            de las expresiones regulares, pueden ser algo mÃ¡s difÃ­ciles de
            seleccionar. En estos escenarios, utilizamos la contra barra.
          </p>
          <p>
            Si intentamos seleccionar solamente los puntos sin utilizar la
            contra barra, podemos ver que, en este caso, nos seleccionarÃ­a todo
            el contenido.
          </p>
          <p>
            En cambio, si aÃ±adimos una contra barra, podemos ver que ahora si
            que nos selecciona concretamente el . sin ningÃºn carÃ¡cter adicional.
          </p>
        </section>
      </article>
      <article class="content">
        <section>
          <h2 id="chacla">3. Character Classes ğŸ”¤</h2>
          <h3 id="decdig">3.1 - Decimal digit \d & not decimal digit \D ğŸ’¯</h3>
          <h4>Decimal digit ğŸ”¢</h4>
          <p>
            \d con la d en minÃºsculas, selecciona cualquier carÃ¡cter numÃ©rico.
          </p>
          <p>El patrÃ³n \d serÃ­a equivalente a utilizar [0-9].</p>
          <h4>Not a decimal digit ğŸ™…â€â™‚ï¸</h4>
          <p>
            \D con la D en mayÃºsculas, selecciona cualquier carÃ¡cter que NO sea
            un nÃºmero.
          </p>
          <p>El patrÃ³n \D serÃ­a equivalente a utilizar [^0-9].</p>
        </section>
        <section>
          <h3 id="whitespace">
            3.2 - White-space characters \s & Not-white-space chars \S ã€°ï¸
          </h3>
          <h4>White space characters \s ã€°ï¸</h4>
          <p>
            \s con la d en minÃºsculas, selecciona cualquier carÃ¡cter que sea un
            espacio.
          </p>
          <h4>Not white space characters \S ğŸš«ã€°ï¸</h4>
          <p>
            \S con la d en mayÃºsculas, selecciona cualquier carÃ¡cter que NO sea
            un espacio.
          </p>
        </section>
        <section id="word">
          <h3>3.3 - Word \w & non-word \W ğŸ” </h3>
          <h4>Rango por defecto de Word \w ğŸ”¡</h4>
          <p>
            \w Con la \w en minÃºsculas se selecciona cualquier carÃ¡cter de una
            palabra independientemente de que este sea un nÃºmero o una letra (a
            excepciÃ³n de la Ã±)
          </p>
          <p>
            Fijaros que solamente se seleccionan los caracteres de texto (a
            excepciÃ³n de la Ã±) y/o numÃ©ricos. El resto de caracteres, por
            ejemplo: sÃ­mbolos de exclamaciÃ³n, @, *â€¦ no se seleccionarÃ¡n.
          </p>
          <p class="recuadro">
            ğŸ’¡ \w es una abreviatura de Word que es equivalente al siguiente
            patrÃ³n de grupo: [a-zA-Z0-9]
          </p>
          <h4>Ampliando el rango por defecto de Word \w ğŸŒ…</h4>
          <p>
            [\wÃ±Ã‘] es equivalente al siguiente patrÃ³n de grupo [a-zÃ±A-ZÃ‘0-9] .
            Como necesitamos aÃ±adir la Ã±, para ello, hemos creado un grupo de
            tal forma que en ambos patrones estamos haciendo lo mismo de maneras
            totalmente distintas. Aunque con la primera forma estamos
            simplificando esto mismo a una forma mÃ¡s reducida.
          </p>
          <h4>Rango por defecto de non-word \W ğŸš«ğŸ” </h4>
          <p>
            \W Con la \W en mayÃºsculas, selecciona cualquier carÃ¡cter que no sea
            de una palabra.
          </p>
          <p class="recuadro">
            ğŸ’¡ \W es una abreviatura de Non-word que es equivalente al siguiente
            patrÃ³n de grupo: [^a-zA-Z0-9_]
          </p>
          <h4>Ampliando el rango por defecto de non-word \W ğŸŒ„</h4>
          <p>
            De la misma manera que en el ejemplo anterior con word, podemos
            ampliar el rango de non-word sin problema.
          </p>
          <h4>Alternation ã€½</h4>
          <p>
            Aunque la manera anterior considero que es mucho mÃ¡s Ã³ptima, vamos a
            ver otra manera de seleccionar un grupo mediante a alternation. En
            el funcionamiento y el uso de alternaciones nos detendremos un
            poquito mÃ¡s adelante en su debida secciÃ³n.
          </p>
          <p>
            \W|a|A|e|E ğŸ¡¢ Seleccionamos todos los carÃ¡cteres que no son letras o
            nÃºmeros a excepciÃ³n de a, A, e, E.
          </p>
        </section>
        <section id="carriage">
          <h3>3.4 - Carriage returns y line feeds ğŸ›’</h3>
          <h4>Â¿QuÃ© son los retornos de carro? â—€ğŸ›’</h4>
          <p>
            Los retornos de carro (carriage returns) y saltos de lÃ­nea (line
            feeds) son caracteres especiales que se utilizan para controlar el
            formato del texto en los archivos.
          </p>
          <p>
            En las expresiones regulares, estos caracteres pueden tener
            significados especÃ­ficos segÃºn la implementaciÃ³n y el contexto en el
            que se utilicen.
          </p>
          <p>
            Sin embargo, en la mayorÃ­a de las implementaciones de expresiones
            regulares, estos caracteres no pueden ser utilizados directamente en
            un patrÃ³n.
          </p>
          <p>
            La razÃ³n principal por la que los retornos de carro y saltos de
            lÃ­nea no se pueden usar en un patrÃ³n de expresiones regulares es que
            estos caracteres son considerados parte del propio patrÃ³n y no
            pueden usarse para representar lÃ­neas nuevas en el patrÃ³n mismo.
          </p>
          <p>
            Esto podrÃ­a generar ambigÃ¼edad y dificultades en la interpretaciÃ³n
            del patrÃ³n.
          </p>
          <p class="recuadro">
            ğŸ’¡ Generalmente usamos las secuencias de escape para representar
            estos caracteres de manera explÃ­cita en el patrÃ³n.
          </p>
          <h4>
            Â¿CÃ³mo podemos usar estos retornos de carro y saltos de lÃ­nea? ğŸ†™
          </h4>
          <p>
            Para usar este tipo de expresiones vamos a utilizar el lenguaje de
            programaciÃ³n JavaScript junto a una herramienta en lÃ­nea llamada
            JSBIN, la cual proporciona un entorno de desarrollo y prueba para
            HTML, CSS y JavaScript.
          </p>
          <p>
            AquÃ­ tenÃ©is el enlace para acceder a dicha plataforma:
            <a
              href="https://jsbin.com/hijipuruzu/edit?js,console"
              target="_blank"
              >Enlace a la pagina</a
            >.
          </p>
          <p>
            Vamos a configurarla de tal manera que vamos a tener las pestaÃ±as de
            JavaScript y la de la consola de output.
          </p>
          <img src="../images/regexp/jsoutput.png" id="img-jsoutput" alt="" />
          <h4>Horizontal tab \t ğŸ”­</h4>
          <p>
            \t en minÃºscula se utiliza para aÃ±adir tabulaciones dentro de un
            texto.
          </p>
          <p>
            Si aÃ±adimos una tabulaciÃ³n \t entre el Hola, y el Â¿QuÃ© tal? el
            resultado serÃ¡ el siguiente:
          </p>
          <img src="../images/regexp/t.png" id="img-t" alt="" />
          <h4>New line \n ğŸ†•</h4>
          <p>
            \n en minÃºscula se utiliza para aÃ±adir una new line (salto de lÃ­nea)
            dentro de un texto.
          </p>
          <p>El resultado serÃ¡ el siguiente:</p>
          <img src="../images/regexp/n.png" id="img-n" alt="" />
        </section>
      </article>
      <article class="content">
        <section id="quanti">
          <h2>4. Quantifiers ğŸ</h2>
          <h3 id="short">
            4.1 - 0 or more times (*), 1 or more times (+), 0 or 1 time (?) â˜
          </h3>
          <h4>Â¿QuÃ© son los quantifiers/cuantificadores? âŒ›</h4>
          <p>
            Los cuantificadores dentro de las expresiones regulares (regex) son
            caracteres especiales que se utilizan para especificar la cantidad
            de veces que un elemento debe coincidir en una cadena de texto.
          </p>
          <p class="recuadro">
            ğŸ’¡ Los cuantificadores permiten hacer que su patrÃ³n regex sea mÃ¡s
            flexible y conciso. AdemÃ¡s, especifican con quÃ© frecuencia debe
            coincidir una expresiÃ³n regular o parte de ella.
          </p>
          <p>BasÃ¡ndonos sobre el siguiente texto:</p>
          <p>
            AB <br />
            A_B <br />
            A__B <br />
            A___B <br />
            A____B
          </p>
          <p>
            Con este patrÃ³n, estamos buscando los que literalmente tengan A_B:
          </p>
          <img src="../images/regexp/q1.png" id="img-q1" alt="" />
          <p>
            Pero Â¿CÃ³mo harÃ­amos si quisiÃ©ramos seleccionar todos los elementos
            que tengan AB los que tengan barras bajas de por medio y los que no?
          </p>
          <h4>0 or more times * ğŸ•—</h4>
          <p>
            * define que el patrÃ³n o la parte del patrÃ³n definida debe coincidir
            cero o mÃ¡s veces. Vamos a ver un ejemplo:
          </p>
          <p>
            Por ejemplo, A_*B buscarÃ¡ coincidencias con AB sin ninguna _ o con
            mÃºltiples _ en una fila.
          </p>
          <img src="../images/regexp/q2.png" id="img-q2" alt="" />
          <p class="recuadro">
            ğŸ’¡ Si nos fijamos, estamos seleccionado todos los AB, ya que con el
            _* le estamos especificando que nos seleccionÃ© todos los elementos
            ya tenga 0, 1 o mÃºltiples coincidencias.
          </p>
          <img src="../images/regexp/q3.png" id="img-q3" alt="" />
          <h4>0 or 1 time ? ğŸ••</h4>
          <p>
            ? define que el patrÃ³n o la parte del patrÃ³n definida debe estar
            presente 1 vez o ninguna. Vamos a ver un ejemplo:
          </p>
          <img src="../images/regexp/q4.png" id="img-q4" alt="" />
        </section>
        <section id="exact">
          <h3>
            4.2 - Exactly n times {n}, at least n times {n,} and from n to m
            times {n,m} ğŸ•›
          </h3>
          <h4>Exactly n times {n} ğŸ•›</h4>
          <p>
            {n} define que el patrÃ³n o la parte del patrÃ³n definida debe
            coincidir n veces. Vamos a ver un ejemplo:
          </p>
          <p>
            Con este patrÃ³n A_{2}B, estamos buscando los casos que literalmente
            tengan literalmente dos __ entre AB:
          </p>
          <img src="../images/regexp/q5.png" id="img-q5" alt="" />
          <h4>At least n times {n,} ğŸ••</h4>
          <p>
            {n,} define que el patrÃ³n o la parte del patrÃ³n definida debe
            coincidir n o mÃ¡s veces. Vamos a ver un ejemplo:
          </p>
          <p>
            Con este patrÃ³n A_{2,}B, estamos buscando los casos que literalmente
            tengan literalmente dos __ o mÃ¡s _ entre AB:
          </p>
          <img src="../images/regexp/q6.png" id="img-q6" alt="" />
          <h4>From n to m times {n,m} ğŸ•–</h4>
          <p>
            {n,m} define que el patrÃ³n o la parte del patrÃ³n definida debe
            coincidir dentro del rango de n veces a m veces. Vamos a ver un
            ejemplo:
          </p>
          <img src="../images/regexp/q7.png" id="img-q7" alt="" />
        </section>
        <section id="grla">
          <h3>4.3 - Greedy/codicioso VS Lazy/Perezoso ğŸ¦¥</h3>
          <p>
            La principal diferencia entre "greedy" (codicioso) y "lazy"
            (perezoso) en el contexto de expresiones regulares es cÃ³mo manejan
            las repeticiones. Estos tÃ©rminos se aplican a los cuantificadores,
            como *, +, ?, {n,m}, etc., y afectan la forma en que se realiza la
            coincidencia en el texto.
          </p>
          <h4>Greedy/Codicioso ğŸ’°</h4>
          <p>
            Greedy = â€˜Codiciosoâ€™ intentarÃ¡ matchear la cadena mÃ¡s larga posible.
            Es decir, si tiene varias opciones donde parar irÃ¡ hasta la mÃ¡s
            lejana ya que es codicioso y tiene muchas ganas de trabajar.
          </p>
          <p>BasÃ¡ndonos sobre el siguiente texto:</p>
          <p>stackoverflow</p>
          <p>
            Con greedy (el codicioso) llegaremos a la o mÃ¡s lejana de las dos
            que tenemos:
          </p>
          <img src="../images/regexp/q8.png" id="img-q8" alt="" />
          <h4>Lazy/Perezoso ğŸ¦¥</h4>
          <p>
            Lazy = â€˜Perezosoâ€™ intentarÃ¡ coger la cadena mÃ¡s cercana posible. Es
            decir, si tiene varias opciones donde parar irÃ¡ hasta la mÃ¡s cercana
            ya que es perezoso y no tiene muchas ganas de trabajar.
          </p>
          <p>
            Con el lazy (el perezoso), en cambio, queremos acabar cuanto antes.
            Por lo que cogemos la cadena mÃ¡s corta posible. Vamos a ver un
            ejemplo:
          </p>
          <img src="../images/regexp/q9.png" id="img-q9" alt="" />
        </section>
      </article>
      <article class="content">
        <section>
          <h2 id="anchors">5. Anchors ğŸ”±</h2>
          <h3 id="stend">
            5.1 - Start at beginning of String (^) & end of String ($) âš“
          </h3>
          <p>
            Existen mecanismos, es decir ciertos caracteres ($ y ^) mediante a
            los cuales podemos comprobar/â€anclarâ€ si una cadena empieza o acaba
            por un patrÃ³n. Os explicamos como funcionan.
          </p>
          <h4>Start at beginning of String ^ âš“</h4>
          <p>^ el patrÃ³n empieza porâ€¦</p>
          <p>BasÃ¡ndonos sobre el siguiente texto:</p>
          <p>
            abc <br />
            babc <br />
            cabcde <br />
            ddeabc
          </p>
          <p>
            Si escribimos el patrÃ³n abc, vemos que se matchearÃ¡n todos los casos
            en los que abc estÃ© presente. Independientemente de si estÃ¡ al
            inicio, al final o en el centro de la cadena.
          </p>
          <img src="../images/regexp/a1.png" id="img-a1" alt="" />
          <p>
            En cambio, si queremos matchear solamente los casos que empiecen por
            abc , debemos de aÃ±adir el ^ antes del texto. Vamos a ver un
            ejemplo:
          </p>
          <img src="../images/regexp/a2.png" id="img-a2" alt="" />
          <h4>End of String $ ğŸš¢</h4>
          <p>$ El patrÃ³n acaba conâ€¦</p>
          <p>
            Si queremos seleccionar las cadenas de texto que acaban pro bc, el
            regex para hacer el match serÃ­a el siguiente:
          </p>
          <img src="../images/regexp/a3.png" id="img-a3" alt="" />
          <h4>Combinando ^ con $ ğŸš¢âš“</h4>
          <p>
            Existe tambiÃ©n la posibilidad de que $ y ^ convivan dentro de un
            mismo patrÃ³n.
          </p>
          <p>
            Por ejemplo, el siguiente ejemplo solo matchearÃ¡ los casos en los
            que la lÃ­nea empiece y acabe por abc:
          </p>
          <img src="../images/regexp/a4.png" id="img-a4" alt="" />
        </section>
        <section>
          <h3 id="wordbound">
            5.2 - Word buoundary \b & not word boundary \B ğŸš
          </h3>
          <h4>Word buoundary \b sin texto âš“</h4>
          <p>
            \b en minÃºscula y sin ir englobada sobre un texto (\bTEXT\b)
            representa un lÃ­mite de palabra (word boundary). Es decir, actÃºa
            como un ancla que marca la posiciÃ³n entre caracteres de palabra
            (alfanumÃ©ricos) y caracteres que no son de palabra (como espacios,
            signos de puntuaciÃ³n, etc.).
          </p>
          <p>
            Inicialmente, si utilizamos \b sin nada mÃ¡s en el siguiente texto
            podemos observar que se selecciona el inicio y fin de cada una de
            las palabras.
          </p>
          <h4>Word buoundary \b con texto âš“ğŸ“‹</h4>
          <p>
            \b en minÃºscula, representa un lÃ­mite de palabra (word boundary)
            actÃºa como delimitador de palabras lo que nos permite delimitar una
            palabra de inicio a fin, evitando que se cuelen subcadenas de dentro
            de otras palabras mÃ¡s largas. De tal forma que nos garantiza que
            estamos buscando palabras exactas en lugar de partes de palabras.
            Esto es especialmente Ãºtil en escenarios como la bÃºsqueda y
            reemplazo de palabras en un texto.
          </p>
          <p class="recuadro">
            ğŸ’¡ Englobando una palabra con \b nos aseguramos que seleccionaremos
            Ãºnica y exclusivamente las palabras contenidas entre las dos
            \bWORD\b de tal manera que solamente seleccionaremos las que
            empiecen y acaben de tal forma. Y no las que contengan dicha
            palabra.
          </p>
          <h4>Not word boundary \B caracteres de entre palabras ğŸ“–</h4>
          <p>
            La secuencia de escape \B matchearÃ¡ a cualquier carÃ¡cter siempre que
            no este no se encuentre en el lÃ­mite de palabra. En otras palabras,
            coincide con posiciones dentro de palabras o entre caracteres que
            son todos alfanumÃ©ricos.
          </p>
        </section>
      </article>
      <article class="content">
        <section>
          <h2 id="alternation">6. Alternation âš¡</h2>
          <h3>6.1 - Alternation |</h3>
          <p>
            | la alternaciÃ³n dentro de las expresiones regulares se refiere a la
            capacidad de especificar mÃºltiples alternativas sobre el patrÃ³n que
            busca en una cadena de texto. Para ello, se utiliza el operador de
            barra vertical | separando cada una de las alternativas.
          </p>
          <h3>
            6.2 - Match y match matchea la expresiÃ³n completa o sino no se
            matchea ğŸ¯
          </h3>
          <p>
            La construcciÃ³n (?(exp)yes|no) es parte de las expresiones regulares
            condicionales y permite definir un patrÃ³n que coincide con "yes" si
            la expresiÃ³n condicional exp es verdadera y con "no" si es falsa.
            AquÃ­ tienes un ejemplo de cÃ³mo usar esta construcciÃ³n en una
            expresiÃ³n regular:
          </p>
          <img src="../images/regexp/alt1.png" id="img-alt1" alt="" />
        </section>
      </article>
      <article class="content">
        <section>
          <h2 id="gruprarus">7. Groups rarunos ğŸ¸</h2>
          <ol>
            <li>
              \L$1: Todas las palabras en el grupo coincidente se cambiarÃ¡n a
              minÃºsculas.
            </li>
            <li>
              \l$1: La primera letra en el grupo coincidente estarÃ¡ en
              minÃºscula, el resto permanecerÃ¡ sin cambios.
            </li>
            <li>
              \U$1: Todas las palabras en el grupo coincidente se cambiarÃ¡n a
              mayÃºsculas.
            </li>
            <li>
              \u$1: La primera letra en el grupo coincidente estarÃ¡ en
              mayÃºscula, el resto permanecerÃ¡ sin cambios.
            </li>
          </ol>
        </section>
      </article>
      <article class="content">
        <h3>ğŸ¥©Chuletita Cheat sheetğŸ¥©</h3>
        <img src="../images/regexp/chuleta.png" id="img-chuleta" alt="" />
      </article>
      <article class="content">
        <h2 id="webrecom">ğŸ¤“Webs recomendadasğŸ¤“</h2>
      </article>
    </main>
    <footer>
      StudyWeb Â© 2024 Todos los derechos reservados. |
      <a href="#">PolÃ­tica de privacidad</a> |
      <a href="#">TÃ©rminos y condiciones</a> | <a href="#">Contacto</a>
    </footer>
  </body>
</html>
