<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StudyWeb - Sergio Robla</title>
    <link
      rel="shortcut icon"
      href="../assets/icons/icon.png"
      type="image/x-icon"
    />
    <link rel="stylesheet" href="../styles/style.css" />
  </head>
  <body id="inicio">
    <header>
      <nav class="menu">
        <div class="logo">
          <a href="../index.html"
            ><img src="../assets/icons/icon.png" alt="logo"
          /></a>
        </div>
        <div class="enlaces">
          <a href="../about/regexp.html">RegExpüß©</a>
          <a href="../about/git.html">Gitüê±</a>
          <a href="../about/markdown.html">Markdown‚úçÔ∏è</a>
          <a href="../about/hyperText.html">Htmlüåê</a>
          <a href="../about/cascadeStyle.html">Cssüé®</a>
          <a href="../about/bootstrap.html">BootstrapüÖ±Ô∏è</a>
          <a href="../about/javaScript.html">JavaScriptüß†</a>
          <a href="../about/mySql.html">MySQLüóÉÔ∏è</a>
          <a href="../about/studyJava.html">Java‚òï</a>
          <a href="../about/springBoot.html">Spring BootüöÄ</a>
          <a href="../about/react.html">React‚öõÔ∏è</a>
        </div>
      </nav>
    </header>
    <main>
      <nav class="menu-page">
        <ul>
          <li><a href="#inicio">Men√∫üè†</a></li>
          <li><a href="#reg-introduccion">Introducci√≥nüîç</a></li>
          <li><a href="#reg-queson">¬øQu√© son?ü§î</a></li>
          <li><a href="#reg-historia">Historiaüï∞Ô∏è</a></li>
          <li><a href="#reg-pqsirven">¬øPara qu√©?üéØ</a></li>
          <li><a href="#reg-ejemplo">B√∫squedaüîç</a></li>
          <li><a href="#reg-motores">MotoresüöÄ</a></li>
          <li><a href="#reg-patmat">PatternüéØ</a></li>
          <li><a href="#reg-single">Singleüï∫</a></li>
          <li><a href="#reg-estrella">Estrellaüåü</a></li>
          <li><a href="#reg-congrup">Contenidoüì¶</a></li>
          <li><a href="#reg-nocongrup">No Contenidoüö´</a></li>
          <li><a href="#reg-defrang">Rangosüìä</a></li>
          <li><a href="#reg-joker">JokerüÉè</a></li>
          <li><a href="#reg-chacla">Classesüî§</a></li>
          <li><a href="#reg-decdig">Decimalüíπ</a></li>
          <li><a href="#reg-whitespace">Espacioüåå</a></li>
          <li><a href="#reg-word">Word‚ú®</a></li>
          <li><a href="#reg-carriage">Carriageüõí</a></li>
          <li><a href="#reg-quanti">QuantifiersüèÅ</a></li>
          <li><a href="#reg-short">Shorts Times‚è≥</a></li>
          <li><a href="#reg-exact">Exactly Times‚è±Ô∏è</a></li>
          <li><a href="#reg-grla">Greedy - Lazyü¶•</a></li>
          <li><a href="#reg-anchors">Anchors‚öì</a></li>
          <li><a href="#reg-stend">Stringüßµ</a></li>
          <li><a href="#reg-wordbound">Buoundaryüîç</a></li>
          <li><a href="#reg-alternation">Alternation‚ö°</a></li>
          <li><a href="#reg-gruprarus">Rarosüê∏</a></li>
          <li><a href="#reg-webrecom">Websü§ì</a></li>
        </ul>
      </nav>
      <article class="content">
        <section id="reg-intro">
          <h1 class="main-title">üîçRegular Expressionüß©</h1>
          <div>
            <p>
              Las Expresiones Regulares, com√∫nmente conocidas como Regex, son
              una herramienta poderosa para trabajar con texto. Son patrones que
              permiten buscar, reemplazar, y manipular cadenas de caracteres con
              gran precisi√≥n y flexibilidad. Las regex se utilizan en la
              programaci√≥n y en herramientas de procesamiento de texto para
              realizar tareas complejas de b√∫squeda y edici√≥n de forma
              eficiente.
            </p>
            <p>
              Por ejemplo, una expresi√≥n regular puede ser utilizada para
              validar el formato de un correo electr√≥nico, asegur√°ndose de que
              cumpla con un patr√≥n est√°ndar como usuario@dominio.com. La regex
              para esta tarea podr√≠a ser algo as√≠ como
              ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$, donde cada parte
              del patr√≥n define un aspecto espec√≠fico de lo que se considera un
              correo electr√≥nico v√°lido.
            </p>
            <p>
              Otro uso com√∫n de las regex es la b√∫squeda de patrones dentro de
              un texto, como identificar todas las fechas en un formato
              espec√≠fico dentro de un documento. Por ejemplo, para encontrar
              fechas en el formato dd/mm/aaaa, podr√≠amos usar la regex
              \b\d{2}/\d{2}/\d{4}\b, que busca secuencias de dos d√≠gitos,
              seguidas de una barra, otros dos d√≠gitos, otra barra, y finalmente
              cuatro d√≠gitos.
            </p>
            <p>
              Las regex tambi√©n son √∫tiles para dividir texto en tokens o
              segmentos, como separar palabras o frases en un p√°rrafo. Por
              ejemplo, para dividir un texto por espacios y puntuaci√≥n podr√≠amos
              usar una regex como [\s,.]+, que identifica espacios, comas y
              puntos como delimitadores.
            </p>
            <p>
              En resumen, las Expresiones Regulares son una herramienta esencial
              para cualquier persona que trabaje con texto, ya que proporcionan
              un m√©todo poderoso y vers√°til para realizar b√∫squedas y ediciones
              complejas en cadenas de caracteres.
            </p>
          </div>
        </section>
        <section id="reg-introduccion">
          <h2>1. Introducci√≥n a las expresiones regulares üîç</h2>
          <div id="reg-queson">
            <h3>1.1 - ¬øQu√© son las expresiones regulares? ü§î</h3>
            <p>
              El t√©rmino de expresiones regulares nace a partir del t√©rmino
              ingl√©s Regular Expressions, del que tambi√©n surgen varias
              abreviaturas como RegEx (de REGular EXpressions) o RegExp (de
              REGular EXPressions).
            </p>
            <p class="recuadro">
              üß† Las expresiones regulares (RegEx), no son un lenguaje de
              programaci√≥n, sino una serie de s√≠mbolos (expresiones o patrones)
              que nos permitir√°n definir patrones de b√∫squeda en cadenas de
              texto.
            </p>
            <p>
              Por tanto, no son nada m√°s y nada menos que una "especie de
              lenguaje" para manipular/realizar b√∫squedas sobre los archivos de
              texto o simplemente sobre textos sin la necesidad de que estos
              est√©n contenidos en el interior de un fichero.
            </p>
          </div>
          <div id="reg-historia">
            <h3>1.2 - Historia y origen de las expresiones regulares üï∞Ô∏è</h3>
            <h4>Avances hasta la d√©cada de los 40 üìú</h4>
            <p>
              La historia de las expresiones regulares se remonta a la d√©cada de
              1940 y est√° estrechamente relacionada con los avances en la l√≥gica
              matem√°tica y la teor√≠a de la computaci√≥n.
            </p>
            <p class="recuadro">
              ü§ñ El desarrollo de las expresiones regulares se bas√≥ en
              investigaciones previas sobre aut√≥matas finitos y la formulaci√≥n
              de lenguajes formales. Durante la d√©cada de 1930 y 1940, varios
              matem√°ticos y l√≥gicos, incluyendo a Alonzo Church, Alan Turing,
              Emil Post y otros, estaban explorando los conceptos fundamentales
              de la teor√≠a de la computaci√≥n y la l√≥gica matem√°tica.
            </p>
            <h4>
              Pitts & McCulloch: creando la neurona de McCulloch - Pitts üß†
            </h4>
            <p>
              El origen o los inicios de la creaci√≥n de las expresiones
              regulres, tiene su origen en la neurociencia y no en la ciencia de
              la inform√°tica. Concretamente en 1943, en el estudio realizado por
              los padres de la neurona de Pitts & McCulloch.
            </p>
            <p>
              Esta investigaci√≥n fue plasmada en el documento "<a
                href="../docs/mccolloch.logical.calculus.ideas.1943.pdf"
                target="_blank"
                >A Logical calculus of the ideas immanent in nervous activity</a
              >" .
            </p>
            <p>
              Los avances realizados en este estudio fueron utilizados a
              posteriori dentro del campo de la inform√°tica para en la
              idealizaci√≥n de las expresiones regulares.
            </p>
            <h4>Kleene la "estrella" del regex üåü</h4>
            <p>
              En la d√©cada de 1950, el matem√°tico y l√≥gico estadounidense
              Stephen Cole Kleene introdujo el t√©rmino "expresi√≥n regular" por
              primera vez dentro de su trabajo de investigaci√≥n llamado "<a
                href="../docs/RM704.pdf"
                target="_blank"
                >Representation of events in nerve nets and finite automata</a
              >" en la que refleja sus investigaciones en teor√≠a de aut√≥matas y
              lenguajes formales.
            </p>
            <p class="recuadro">
              ü§ñ Cuando hablamos de teoe√≠a de aut√≥matas, nos referimos a la rama
              de la inform√°tica te√≥rica y las matem√°ticas que se centran en el
              estudio de modelos abstractos de m√°quinas o dispositivos que
              pueden realizar ciertas operaciones sobre cadenas de s√≠mbolos. La
              teor√≠a de lenguajes formales estudia patrones de cadenas de
              s√≠mbolos y sus propiedades mediante gram√°ticas y aut√≥matas, siendo
              fundamental en la comprensi√≥n y an√°lisis de lenguajes de
              programaci√≥n, procesamiento de texto y verificaci√≥n de software.
            </p>
            <p>
              Si nos fijamos, en la primera l√≠nea podemos ver que el proyecto se
              llama RAND y fue encargado por la U.S. AIR FORCE.
            </p>
            <p>
              Las expresiones regulares son patrones textuales que describen
              conjuntos de cadenas de caracteres. Permiten la descripci√≥n y
              manipulaci√≥n de lenguajes regulares, que son un tipo de lenguaje
              formal en la teor√≠a de lenguajes formales.
            </p>
            <p>
              Estas expresiones se utilizan en muchos contextos, incluyendo la
              b√∫squeda y manipulaci√≥n de texto en editores de texto,
              procesamiento de cadenas en programaci√≥n, y en el dise√±o de
              motores de b√∫squeda y sistemas de filtrado de informaci√≥n.
            </p>
            <p>
              Kleene formaliz√≥ las expresiones regulares utilizando notaci√≥n
              matem√°tica y desarroll√≥ m√©todos para analizar y generar patrones
              de texto utilizando estas expresiones.
            </p>
            <p>
              Para ello, utiliz√≥ s√≠mbolos como "*" para denotar repetici√≥n y "+"
              para denotar al menos una repetici√≥n de un s√≠mbolo o grupo de
              s√≠mbolos en una expresi√≥n.
            </p>
            <p>
              Estos s√≠mbolos y la notaci√≥n matem√°tica que desarroll√≥ permitieron
              describir patrones de manera m√°s concisa y precisa.
            </p>
            <p class="recuadro">
              ü§ñ Con el tiempo, las expresiones regulares se convirtieron en un
              componente esencial en la programaci√≥n y la manipulaci√≥n de texto
              en sistemas inform√°ticos. Se incorporaron en varios lenguajes de
              programaci√≥n y herramientas, lo que permiti√≥ a los desarrolladores
              realizar tareas de b√∫squeda, extracci√≥n y manipulaci√≥n de patrones
              de manera m√°s eficiente. Desde entonces, las expresiones regulares
              han evolucionado y se han vuelto ubicuas en la inform√°tica y el
              procesamiento de datos.
            </p>
            <h4>Ken Thompson, finalmente implementa üíª</h4>
            <p>
              Durante los a√±os 60, Ken Thompson, un cient√≠fico de la computaci√≥n
              que destaca por ser uno de los creadores del sistema operativo
              Unix, tuvo un papel muy significativo en la evoluci√≥n y
              popularizaci√≥n de las expresiones regulares en el √°mbito de la
              inform√°tica.
            </p>
            <p>
              Aunque Stephen Cole Kleene introdujo el concepto de expresiones
              regulares en la teor√≠a matem√°tica, Ken Thompson fue quien llev√≥
              estas ideas a la pr√°ctica y las integr√≥ en el mundo de la
              programaci√≥n y la inform√°tica pr√°ctica.
            </p>
            <p>
              Thompson implement√≥ las expresiones regulares dentro de un editor
              de texto llamado ‚ÄúED‚Äù lo que permit√≠a a los usuarios realizar
              operaciones con la finalidad de que los usuarios pudieran realizar
              ciertas operaciones de edici√≥n de texto utilizando expresiones
              regulares.
            </p>
            <p>
              Aqu√≠ podemos ver el art√≠culo "<a
                href="../docs/Thompson-1968.pdf"
                target="_blank"
                >Regular Expression Search</a
              >" escrito por el mismo Thompson para Bell Telephone Laboratories,
              en el que detalla aspectos sobre el algoritmo que utiliz√≥ para
              implementar las expresiones regulares dentro del editor de texto
              EQ.
            </p>
            <p class="recuadro">
              ü§ñ Thompson realiza el hito que representa el punto de entrada de
              las expresiones regulares RegEx dentro de la inform√°tica.
            </p>
            <p class="recuadro">
              üéì Posteriormente, Thompson trabajando junto con Dennis Ritchie,
              desarrollaron el lenguaje de programaci√≥n "grep" (que significa
              "global regular expression print"), que permit√≠a buscar patrones
              en archivos y mostrar las l√≠neas que coincid√≠an con esas
              expresiones regulares. La utilidad "grep" se convirti√≥ en una
              herramienta esencial en Unix y otros sistemas operativos basados
              en Unix.
            </p>
            <p>
              Aunque las expresiones regulares han evolucionado a lo largo del
              tiempo, y en algunos aspectos nada tiene que ver con las de aquel
              entonces, tal y como pod√©is observar en el siguiente
              <a href="../docs/qedman.pdf" target="_blank"
                >memorando escrito para Bells Labs en 1970</a
              >
              , algunas de las caracter√≠sticas de expresiones regulares de QED
              se siguen manteniendo a d√≠a de hoy despu√©s de tantos a√±os.
            </p>
            <h4>
              Larry Wall implementa las expresiones por primera vez dentro de
              Perl üí°
            </h4>
            <p>
              Larry Wall, el creador del lenguaje Perl, introdujo expresiones
              regulares dentro del lenguaje.
            </p>
            <p>
              Consiguiendo que las expresiones regulares fueran f√°ciles de usar
              y agregando caracter√≠sticas avanzadas como remplazos y capturas.
              Tambi√©n populariz√≥ conceptos como "greediness" en las
              coincidencias.
            </p>
            <p class="recuadro">
              üìå Sus contribuciones influyeron en c√≥mo se usan las expresiones
              regulares en la programaci√≥n.
            </p>
            <img
              src="../images/regexp/padres de regex.png"
              id="img-parentsregex"
              alt="Padres de regex"
            />
          </div>
          <div id="reg-pqsirven">
            <h3>1.3 - ¬øPara qu√© sirven las expresiones regulares? üéØ</h3>
            <p>
              Las expresiones regulares son extremadamente √∫tiles en
              determinadas situaciones donde necesitas realizar tareas de
              b√∫squeda y manipulaci√≥n de texto de manera avanzada.
            </p>
            <p>
              Algunos casos t√≠picos en los que se utilizan expresiones regulares
              son:
            </p>
            <ol>
              <li>
                B√∫squeda de patrones: Puedes buscar palabras espec√≠ficas,
                n√∫meros, fechas o cualquier patr√≥n de caracteres en un texto de
                manera m√°s flexible y eficiente que con una simple b√∫squeda de
                texto.
              </li>
              <li>
                Validaci√≥n de datos: Puedes validar si una cadena cumple con un
                formato espec√≠fico, como un n√∫mero de tel√©fono, direcci√≥n de
                correo electr√≥nico, c√≥digo postal, etc.
              </li>
              <li>
                Extracci√≥n de informaci√≥n: Puedes extraer partes espec√≠ficas de
                una cadena que cumplan con un patr√≥n determinado, como obtener
                todos los enlaces de una p√°gina web o extraer datos
                estructurados de un texto.
              </li>
              <li>
                Reemplazo y manipulaci√≥n de texto: Puedes realizar operaciones
                de reemplazo, eliminaci√≥n o modificaci√≥n de texto basado en
                patrones espec√≠ficos.
              </li>
            </ol>
            <p>Algunos ejemplos de todo esto podr√≠an ser:</p>
            <ul>
              <li>
                El proceso de validar si un email tiene un formato correcto o
                no.
              </li>
              <li>
                Substituir cierta informaci√≥n dentro de un documento/archivo.
              </li>
              <li>
                Realizar una modificaci√≥n masiva sobre m√∫ltiples INSERTs de SQL.
              </li>
            </ul>
          </div>
          <div id="reg-ejemplo">
            <h3>
              1.4 - Ejemplo de b√∫squeda de patrones con el comando grep y regexp
              üîç
            </h3>
            <p>
              Una vez aterrizados en la historia y en las expresiones regulares,
              vamos a ver un peque√±o ejemplo de c√≥mo trabajar con ellas mediante
              al comando grep solamente disponible dentro de los sistemas
              operativos que est√°n basados en UNIX.
            </p>
            <h4>¬øQu√© es GREP? ¬øPara qu√© se utiliza? üíª</h4>
            <p>
              GREP es un comando de terminal que nos permite realizar b√∫squedas
              globales.
            </p>
            <p>
              GREP es el acr√≥nimo de Global Regular Expression Print el
              significado de estas siglas es el siguiente:
            </p>
            <ul>
              <li>G ü°¢ Global</li>
              <li>RE ü°¢ Regular Expressions</li>
              <li>P ü°¢ Print</li>
            </ul>
            <p>
              Con GREP, por tanto, vamos a realizar una b√∫squeda Global, es
              decir, sobre una serie de documentos situados en un directorio y
              finalmente vamos a hacer un Print (impresi√≥n) de todas las l√≠neas
              coincidentes mediante a una Regular Expresion.
            </p>
            <p class="recuadro">
              üîé GREP destaca por ser un marcar un antes y un despu√©s, un gran
              paso en c√≥mo realizar b√∫squedas en Unix.
            </p>
            <h4>Trabajando desde la web una terminal UNIX üåê</h4>
            <p>
              Para realizar dicha prueba, vamos a trabajar desde una emulaci√≥n
              web de un sistema UNIX.
            </p>
            <p>
              Para ello, entramos en la siguiente web:
              <a href="https://bellard.org/jslinux/" target="_blank"
                >Entra en la web.</a
              >
            </p>
            <p>
              Una vez dentro, seleccionamos el sistema operativo con el que
              queremos trabajar en mi caso usar√© la siguiente versi√≥n:
            </p>
            <img
              src="../images/regexp/terminal UNIX.png"
              id="img-linuxandother"
              alt="Linux or other operating systems"
            />
            <p>
              Una vez dentro, como podr√©is observar, se nos abrir√° una terminal
              de Linux en el propio browser desde el que podremos ejecutar los
              comandos pertinentes:
            </p>
            <img
              src="../images/regexp/comandos UNIX.png"
              id="img-comandosUnix"
              alt="Comandos UNIX"
            />
            <h4>Creando el fichero a buscar üìÇ</h4>
            <p>
              Primeramente, vamos a hacer un ls (de list) para listar todos los
              ficheros actuales:
            </p>
            <img src="../images/regexp/ls.png" id="img-ls" alt="" />
            <p>
              Posteriormente, creamos un fichero mediante el comando cat de la
              siguiente manera:
            </p>
            <p>Escribimos ü°¢ cat > (nombre del fichero)</p>
            <p>
              En su interior, vamos a escribir el contenido sobre el que
              realizaremos la b√∫squeda con GREP.
            </p>
            <p>
              Para salir del documento si queremos guardar los cambios
              utilizamos Ctrl + D, o si quisi√©ramos salir sin guardar el
              documento Ctrl + C.
            </p>
            <p>
              Finalmente, una vez guardado el fichero, vamos a hacer un ls para
              mostrar si hemos creado el fichero correctamente.
            </p>
            <p>
              Si ejecutamos el comando tail junto al nombre del fichero que
              acabamos de crear, podemos mostrar el contenido del fichero que
              acabamos de introducir en el paso anterior:
            </p>
            <img src="../images/regexp/ls tail.png" id="img-lstail" alt="" />
            <img src="../images/regexp/tail.png" id="img-tail" alt="" />
            <h4>Ejemplo de uso de GREP üìã</h4>
            <p>
              Primer Ejemplo, finalmente, vamos a realizar la primera b√∫squeda
              de la expresi√≥n regexp m√°s sencilla de todas, una palabra sin m√°s.
              Para ello, tenemos que utilizar el comando grep junto a la
              expresi√≥n regular que vamos a buscar, en este caso la palabra
              David entrecomillada. E inmediatamente despu√©s, la ruta sobre la
              que queremos realizar la b√∫squeda.
            </p>
            <p class="recuadro">
              üìÑ Para realizar una b√∫squeda global, es decir, sobre todos los
              directorios utilizamos *
            </p>
            <p>
              Si realizamos la b√∫squeda con todos los caracteres en min√∫sculas,
              fijaros que la consola no imprimir√° ning√∫n resultado:
            </p>
            <img src="../images/regexp/grep1.png" id="img-grep1" alt="" />
            <p>
              En cambio, si repetimos la misma operaci√≥n con el nombre con la D
              en may√∫scula, ahora si que podemos observar que nos devuelve el
              resultado correctamente:
            </p>
            <img src="../images/regexp/grep2.png" id="img-grep2" alt="" />
            <p>
              Segundo Ejemplo, si queremos que la b√∫squeda no sea
              case-sensitive, es decir, a may√∫sculas y min√∫sculas podemos a√±adir
              el flag (la bandera) -i. Vamos a verlo:
            </p>
            <img src="../images/regexp/grep3.png" id="img-grep3" alt="" />
            <p>
              Tercer Ejemplo, Si quisi√©ramos buscar los ficheros que empiecen
              por Hola, har√≠amos lo siguiente:
            </p>
            <img src="../images/regexp/grep4.png" id="img-grep4" alt="" />
            <p>
              Cuarto Ejemplo, Si quisi√©ramos buscar los ficheros que acaben por
              D har√≠amos lo siguiente:
            </p>
            <img src="../images/regexp/grep5.png" id="img-grep5" alt="" />
          </div>
          <div id="reg-motores">
            <h3>
              1.5 - ¬øQu√© son los motores de ejecuci√≥n de regexp? Y tipos engines
              de regexp üöÄ
            </h3>
            <h4>¬øQu√© son los motores de expresiones regulares? üß©</h4>
            <p>
              Los motores (engines) de expresiones regulares, son programas o
              bibliotecas que implementan la capacidad de realizar procesamiento
              e interpretaci√≥n de patrones de expresiones regulares.
            </p>
            <p>
              Estos modelos permiten buscar, comparar y manipular texto
              bas√°ndose en patrones definidos por las expresiones regulares.
            </p>
            <h4>Distintos motores de expresiones regulares üß∞</h4>
            <p>
              Los motores de expresiones regulares se encuentran tanto en
              lenguajes de programaci√≥n (como Java, Python, JavaScript, Perl,
              PHP, .NET, etc.) como herramientas de software (Eclipse, Visual
              Studio Code, etc.) e incluso en sistemas operativos.
            </p>
            <p class="recuadro">
              üîß Cada motor puede tener su propia sintaxis y caracter√≠sticas
              espec√≠ficas para expresiones regulares, pero la idea general es la
              misma: utilizar patrones para realizar operaciones complejas en
              cadenas de texto.
            </p>
            <p>
              Algunos de los principales motores para ejecutar expresiones
              regulares son:
            </p>
            <ol>
              <li>
                Oniguruma ü°¢ Es un motor de expresiones regulares ampliamente
                utilizado que se encuentra en Visual Studio Code, TextMate,
                Ruby, PHP y otros. <br />
                Es conocido por su soporte completo de expresiones regulares con
                muchas caracter√≠sticas y extensiones.
              </li>
              <li>
                Java (java.util.regexp) ü°¢ Proporciona java.util.regex, un
                paquete/librer√≠a que contiene un conjunto de clases que nos va a
                proporcionar un motor de expresiones regulares para trabajar con
                expresiones regulares dentro de Java. Entre las clases m√°s
                utilizadas se encuentra Pattern y Matcher.
                <br />
                Estas clases permiten compilar expresiones regulares, buscar
                coincidencias y realizar operaciones de reemplazo en cadenas.
              </li>
              <li>
                JavaScript (Regexp) ü°¢ Los navegadores y Node.js utilizan el
                motor de expresiones regulares incorporado en JavaScript, que se
                accede a trav√©s de la clase RegExp. Por lo que podemos utilizar
                expresiones regulares de forma nativa en JavaScript para
                realizar b√∫squedas y reemplazos en cadenas de texto.
              </li>
              <li>
                GNU Grep (grep) ü°¢ grep es una herramienta de l√≠nea de comandos
                disponible en sistemas Unix como por ejemplo Linux, que nos
                permite realizar b√∫squedas de patrones utilizando expresiones
                regulares.
              </li>
              <li>
                PCRE (Perl Compatible Regular Expressions) ü°¢ PCRE es un motor de
                expresiones regulares compatible con Perl, que adem√°s se utiliza
                en lenguajes como PHP, Python (a trav√©s del m√≥dulo re), y otros.
                Ofrece una amplia gama de funcionalidades, incluyendo
                expresiones regulares recursivas.
              </li>
              <li>
                PHP (PCRE) ü°¢ PHP utiliza el motor PCRE para su soporte de
                expresiones regulares. Puedes utilizar la funci√≥n preg_match() y
                otras funciones relacionadas para trabajar con expresiones
                regulares.
              </li>
              <li>
                Ruby (Regexp) ü°¢ Ruby proporciona soporte nativo para expresiones
                regulares a trav√©s de la clase Regexp.
              </li>
              <li>
                C# (.NET Regex) ü°¢ C# proporciona soporte para expresiones
                regulares a trav√©s de la clase System Text RegularExpressions
                Regex.
              </li>
              <li>
                Python (re) ü°¢ Python incluye un m√≥dulo llamado re que ofrece
                soporte para expresiones regulares. Este m√≥dulo proporciona
                funciones para trabajar con expresiones regulares que nos
                permitir√°n compilar expresiones regexp, buscar coincidencias y
                realizar cambios de manera similar a Java.
              </li>
            </ol>
            <p class="recuadro">
              ‚Ñπ Estos son solo algunos ejemplos de los motores de expresiones
              regulares disponibles en diferentes lenguajes y herramientas. Cada
              uno de ellos puede tener diferencias en la sintaxis o en las
              caracter√≠sticas admitidas, pero todos est√°n dise√±ados para
              proporcionar una forma poderosa de realizar operaciones avanzadas
              de b√∫squeda y manipulaci√≥n de texto basadas en patrones.
            </p>
          </div>
          <div id="reg-patmat">
            <h3>1.6 - ¬øQu√© es el patr√≥n/pattern y el match? üéØ</h3>
            <h4>¬øQu√© es el patr√≥n, pattern? üß©</h4>
            <p>
              Cuando hablamos de patr√≥n o de pattern, dentro del contexto de las
              expresiones regulares, es a la expresi√≥n, es decir, la secuencia
              de caracteres mediante la cual intentaremos realizar un match
              dentro de un fichero gracias a un motor de expresiones regulares.
            </p>
            <p class="recuadro">
              üßê Cada car√°cter definido dentro del patr√≥n representa una
              instrucci√≥n para buscar cierto tipo de contenido en el texto. Por
              tanto, el patr√≥n no es nada m√°s que una combinaci√≥n de caracteres
              literales y caracteres especiales que tienen ciertos significados
              espec√≠ficos. Los cuales formar√°n la expresi√≥n regular a partir de
              la cual buscaremos las coincidencias (matchings) dentro de un
              texto. Dicho patr√≥n que buscar√° si una determinada expresi√≥n
              regular existe dentro de un determinado texto.
            </p>
            <h4>¬øQu√© es el match (coincidencia)? ‚úÖ</h4>
            <p>
              En el contexto de las expresiones regulares un match, se refiere a
              cada una de las instancias o coincidencias encontradas dentro del
              texto que cumple con lo definido dentro del patr√≥n de la expresi√≥n
              regular.
            </p>
            <p>
              En otras palabras, cuando aplicas una expresi√≥n regular, es decir,
              un patr√≥n generando una cadena de texto, y esa cadena de texto
              buscar√° en el interior de un texto de tal forma que, cada
              resultado encontrado ser√° una coincidencia o un "match".
            </p>
            <p class="recuadro">
              üìå^\d{3} ü°¢ Este patr√≥n significa que selecciona todas las l√≠neas
              que empiecen por 3 d√≠gitos.
            </p>
            <p>
              En resumen, el patr√≥n en una expresi√≥n regular define c√≥mo se
              busca o manipula el texto. Contiene una serie de caracteres que
              representan reglas espec√≠ficas para encontrar patrones
              particulares en las cadenas de texto.
            </p>
            <h4>Instalando plugins para VSC ‚öôÔ∏è</h4>
            <p>
              Existen determinadas expresiones regulares que pueden llegar a ser
              muy complejas y cuya lectura puede ser todo un reto.
            </p>
            <p>
              Un ejemplo de ello es General Email Regex (RFC 5322 Official
              Standard) la cual nos permite realizar la validaci√≥n de un email
              con un 99,99% de eficiencia:
            </p>
            <p>
              >(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"
              (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b
              \x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:
              [a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
              (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\
              x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
            </p>
            <p>
              Si tenemos que interpretar dicha expresi√≥n sin ayuda alguna, esto
              ser√≠a una tarea muy muy muy compleja.
            </p>
            <p>
              Por ello, tenemos determinadas web y plugins que nos permiten
              simplificar en media de lo posible determinadas tareas con regexp.
              Un ejemplo de ello es la siguiente web:
              <a href="https://jex.im/regulex/" target="_blank"
                >Enlace de web</a
              >
            </p>
            <p class="recuadro">
              üèó Si pegamos el c√≥digo de la expresi√≥n regular podemos generar un
              esquema que nos permitir√° entender que hace la expresi√≥n.
            </p>
            <img src="../images/regexp/img jex.png" id="img-jex" alt="" />
          </div>
        </section>
        <section id="reg-single">
          <h2>2. Single Characters üî°</h2>
          <div id="reg-estrella">
            <h3>2.1 - La estrella de Kleene * üåü</h3>
            <h4>
              ¬øQu√© es la estrella de Kleene dentro de las expresiones regulares?
              üåü
            </h4>
            <p>
              La estrella de Kleene (*) es el meta car√°cter m√°s potente de todos
              con el que la comunidad trata de homenajear de Kleene al que en
              general consideran ‚Äúel padre‚Äù de las expresiones regulares.
            </p>
            <p class="recuadro">
              üìå Por el momento solamente vamos a ver solamente uno de sus usos.
              Aunque me gustar√≠a matizar que con la estrella de Kleene podemos
              realizar tambi√©n otras funcionalidades que ya veremos cuando
              lleguemos a dicho apartado.
            </p>
            <p>
              /* ü°¢ Seleccionamos cualquier car√°cter (incluido el salto de l√≠nea
              \n)
            </p>
            <h4>Saltos de l√≠nea en regexp ‚Üµ</h4>
            <p>
              Para poder visualizarlos, podemos ayudarnos de regexp. Para ello,
              realizamos un \n podemos matchear todos los saltos de l√≠nea que
              hay en nuestro documento.
            </p>
            <p class="recuadro">
              üìå Los saltos de l√≠nea no se pueden visualizar a golpe de ojo
              dentro de un documento.
            </p>
            <h4>Espacios en regexp „Ä∞Ô∏è</h4>
            <p class="recuadro">
              üìå Los saltos de l√≠nea los podemos visualizar, detectar o
              identificar f√°cilmente dentro de un documento por la separaci√≥n de
              los caracteres.
            </p>
            <p>
              Adem√°s de ello, si seleccionamos el texto al completo en el
              interior del IDE (Visual Studio Code), podemos observar como
              aparece una especie de puntito ¬∑ el cual representa cada uno de
              los espacios.
            </p>
            <p>
              Si utilizamos \s o en su defecto escribimos un espacio sin nada
              m√°s, podemos ver que hacemos un match de todos los espacios del
              documento.
            </p>
            <h4>Ejemplo de un uso de la estrella de Kleene üå†</h4>
            <p>
              En cambio, si utilizamos la estrella de Kleene, podemos ver que se
              seleccionan todos los caracteres inclusive los saltos de l√≠nea y
              espacios.
            </p>
            <p class="recuadro">
              üìå Por ello, decimos que la estrella de Kleene es el meta car√°cter
              m√°s poderoso de todos, engloba todo incluso los saltos de l√≠nea o
              espacios.
            </p>
          </div>
          <div id="reg-congrup">
            <h3>2.2 - [set] Contenido en el grupo üî£</h3>
            <p>
              En esta secci√≥n vamos a empezar a aprender como trabajar con
              grupos de caracteres adem√°s de explicar que diferencias hay entre
              patr√≥n este tipo de grupos y los caracteres literales. ¬°Vamos a
              ello!
            </p>
            <p class="recuadro">
              üìå [car√°cter/es] buscar√° cualquier car√°cter incluido entre los [].
              A diferencia de los caracteres literales anteriores, con esta
              manera matchear√° todo lo contenido en el interior del par√©ntesis
              independientemente de que est√©n definidos consecutivamente o no.
            </p>
          </div>
          <div id="reg-nocongrup">
            <h3>2.3 - [^set] No contenido en el grupo üö´</h3>
            <p>
              [^car√°cter/es] realizar√° el match de cualquier car√°cter que NO
              est√© incluido dentro de los corchetes [] independiente de si es
              consecutivo o si no.
            </p>
          </div>
          <div id="reg-defrang">
            <h3>2.4 - [set] [^set] Definiendo conjuntos/rangos üé≤</h3>
            <h4>
              Seleccionando un conjunto de letras (abecedario al completo) üî§
            </h4>
            <p>
              De la misma forma que podemos definir un rango mediante a una
              secuencia de caracteres literales, podemos realizarlo mediante a
              un rango/conjunto de la siguiente manera:
            </p>
            <p>
              [a-z] Nos permite definir un rango espec√≠fico dentro del patr√≥n.
            </p>
            <p class="recuadro">
              üö® A excepci√≥n de la √± tanto en may√∫scula como min√∫scula ya que la
              inform√°tica por decirlo as√≠ ‚Äúest√° hecha en ingl√©s‚Äù y la √± no
              existe en dicho lenguaje.
            </p>
            <h4>A√±adiendo caracteres a un conjunto ‚ûï</h4>
            <p>
              Si queremos que dicho rango a√±ada la √± tambi√©n deberemos de
              a√±adirla al conjunto de la siguiente manera [a-z√±].
            </p>
            <h4>Upper & Lower case range üî†</h4>
            <p>
              Las expresiones regulares pueden ser "case sensitive" o "case
              insensitive", lo que significa que pueden o no distinguir entre
              letras may√∫sculas y min√∫sculas en el texto que se est√° analizando.
            </p>
            <h4>Seleccionando un rango num√©rico üî¢</h4>
            <p>[0-9] Tambi√©n podemos utilizar rangos de num√©ricos.</p>
            <h4>Rango de caracteres ‚Äúespeciales‚Äù üî£</h4>
            <p>
              [√Ä-√ø] Otro ejemplo de como seleccionar los caracteres especiales
              (acentuados, dieresis, e√±es‚Ä¶), es decir, que no son utilizados en
              el lenguaje ingl√©s.
            </p>
          </div>
          <div id="reg-joker">
            <h3>2.5 - Uso del meta car√°cter joker, .* & \char üÉè</h3>
            <h4>Uso del meta car√°cter . ‚Äúel famoso joker‚Äù üÉè</h4>
            <p>
              . meta car√°cter tambi√©n conocido como el ‚Äújoker‚Äù, selecciona
              cualquier car√°cter, de una forma similar a ‚Äúun comod√≠n‚Äù ¬°A
              excepci√≥n de los saltos de l√≠nea! Por lo que poder decirlo as√≠ es
              casi igual de poderoso que la estrella de Kleene. Decimos ¬°Casi!
              ya que es un poquit√≠n menos potente.
            </p>
            <p>
              El primer uso que podr√≠amos con . ser√≠a el de seleccionar todos
              los caracteres del documento.
            </p>
            <h4>Doble jocker üÉèüÉè</h4>
            <p>
              ..car√°cter/es ü°¢ Otro uso para el meta car√°cter . es el de a√±adir
              varios puntos a la vez ..
            </p>
            <h4>Joker & Kleene üÉè‚≠ê</h4>
            <p>
              .* ü°¢ Tambi√©n es habitual utilizarlo para seleccionar varios
              caracteres combinado con la famosa estrella de Kleene *.
            </p>
            <p>
              Este patr√≥n ser√° muy √∫til para seleccionar una parte determinada
              en un texto. Por ejemplo, hasta el final de la l√≠nea para
              posteriormente reemplazar dicho contenido.
            </p>
            <h4>
              Seleccionando meta caracteres utilizados en las expresiones
              regulares üî§
            </h4>
            <p>
              \char Existen determinados caracteres como por ejemplo: *,.+ entre
              otros que debido a que tienen alg√∫n significado dentro del
              lenguaje de las expresiones regulares, pueden ser algo m√°s
              dif√≠ciles de seleccionar. En estos escenarios, utilizamos la
              contra barra.
            </p>
            <p>
              Si intentamos seleccionar solamente los puntos sin utilizar la
              contra barra, podemos ver que, en este caso, nos seleccionar√≠a
              todo el contenido.
            </p>
            <p>
              En cambio, si a√±adimos una contra barra, podemos ver que ahora si
              que nos selecciona concretamente el . sin ning√∫n car√°cter
              adicional.
            </p>
          </div>
        </section>
        <section id="reg-chacla">
          <h2>3. Character Classes üî§</h2>
          <div id="reg-decdig">
            <h3>3.1 - Decimal digit \d & not decimal digit \D üíØ</h3>
            <h4>Decimal digit üî¢</h4>
            <p>
              \d con la d en min√∫sculas, selecciona cualquier car√°cter num√©rico.
            </p>
            <p>El patr√≥n \d ser√≠a equivalente a utilizar [0-9].</p>
            <h4>Not a decimal digit üôÖ‚Äç‚ôÇÔ∏è</h4>
            <p>
              \D con la D en may√∫sculas, selecciona cualquier car√°cter que NO
              sea un n√∫mero.
            </p>
            <p>El patr√≥n \D ser√≠a equivalente a utilizar [^0-9].</p>
          </div>
          <div id="reg-whitespace">
            <h3>
              3.2 - White-space characters \s & Not-white-space chars \S „Ä∞Ô∏è
            </h3>
            <h4>White space characters \s „Ä∞Ô∏è</h4>
            <p>
              \s con la d en min√∫sculas, selecciona cualquier car√°cter que sea
              un espacio.
            </p>
            <h4>Not white space characters \S üö´„Ä∞Ô∏è</h4>
            <p>
              \S con la d en may√∫sculas, selecciona cualquier car√°cter que NO
              sea un espacio.
            </p>
          </div>
          <div id="reg-word">
            <h3>3.3 - Word \w & non-word \W üî†</h3>
            <h4>Rango por defecto de Word \w üî°</h4>
            <p>
              \w Con la \w en min√∫sculas se selecciona cualquier car√°cter de una
              palabra independientemente de que este sea un n√∫mero o una letra
              (a excepci√≥n de la √±)
            </p>
            <p>
              Fijaros que solamente se seleccionan los caracteres de texto (a
              excepci√≥n de la √±) y/o num√©ricos. El resto de caracteres, por
              ejemplo: s√≠mbolos de exclamaci√≥n, @, *‚Ä¶ no se seleccionar√°n.
            </p>
            <p class="recuadro">
              üí° \w es una abreviatura de Word que es equivalente al siguiente
              patr√≥n de grupo: [a-zA-Z0-9]
            </p>
            <h4>Ampliando el rango por defecto de Word \w üåÖ</h4>
            <p>
              [\w√±√ë] es equivalente al siguiente patr√≥n de grupo [a-z√±A-Z√ë0-9] .
              Como necesitamos a√±adir la √±, para ello, hemos creado un grupo de
              tal forma que en ambos patrones estamos haciendo lo mismo de
              maneras totalmente distintas. Aunque con la primera forma estamos
              simplificando esto mismo a una forma m√°s reducida.
            </p>
            <h4>Rango por defecto de non-word \W üö´üî†</h4>
            <p>
              \W Con la \W en may√∫sculas, selecciona cualquier car√°cter que no
              sea de una palabra.
            </p>
            <p class="recuadro">
              üí° \W es una abreviatura de Non-word que es equivalente al
              siguiente patr√≥n de grupo: [^a-zA-Z0-9_]
            </p>
            <h4>Ampliando el rango por defecto de non-word \W üåÑ</h4>
            <p>
              De la misma manera que en el ejemplo anterior con word, podemos
              ampliar el rango de non-word sin problema.
            </p>
            <h4>Alternation „ÄΩ</h4>
            <p>
              Aunque la manera anterior considero que es mucho m√°s √≥ptima, vamos
              a ver otra manera de seleccionar un grupo mediante a alternation.
              En el funcionamiento y el uso de alternaciones nos detendremos un
              poquito m√°s adelante en su debida secci√≥n.
            </p>
            <p>
              \W|a|A|e|E ü°¢ Seleccionamos todos los car√°cteres que no son letras
              o n√∫meros a excepci√≥n de a, A, e, E.
            </p>
          </div>
          <div id="reg-carriage">
            <h3>3.4 - Carriage returns y line feeds üõí</h3>
            <h4>¬øQu√© son los retornos de carro? ‚óÄüõí</h4>
            <p>
              Los retornos de carro (carriage returns) y saltos de l√≠nea (line
              feeds) son caracteres especiales que se utilizan para controlar el
              formato del texto en los archivos.
            </p>
            <p>
              En las expresiones regulares, estos caracteres pueden tener
              significados espec√≠ficos seg√∫n la implementaci√≥n y el contexto en
              el que se utilicen.
            </p>
            <p>
              Sin embargo, en la mayor√≠a de las implementaciones de expresiones
              regulares, estos caracteres no pueden ser utilizados directamente
              en un patr√≥n.
            </p>
            <p>
              La raz√≥n principal por la que los retornos de carro y saltos de
              l√≠nea no se pueden usar en un patr√≥n de expresiones regulares es
              que estos caracteres son considerados parte del propio patr√≥n y no
              pueden usarse para representar l√≠neas nuevas en el patr√≥n mismo.
            </p>
            <p>
              Esto podr√≠a generar ambig√ºedad y dificultades en la interpretaci√≥n
              del patr√≥n.
            </p>
            <p class="recuadro">
              üí° Generalmente usamos las secuencias de escape para representar
              estos caracteres de manera expl√≠cita en el patr√≥n.
            </p>
            <h4>
              ¬øC√≥mo podemos usar estos retornos de carro y saltos de l√≠nea? üÜô
            </h4>
            <p>
              Para usar este tipo de expresiones vamos a utilizar el lenguaje de
              programaci√≥n JavaScript junto a una herramienta en l√≠nea llamada
              JSBIN, la cual proporciona un entorno de desarrollo y prueba para
              HTML, CSS y JavaScript.
            </p>
            <p>
              Aqu√≠ ten√©is el enlace para acceder a dicha plataforma:
              <a
                href="https://jsbin.com/hijipuruzu/edit?js,console"
                target="_blank"
                >Enlace a la pagina</a
              >.
            </p>
            <p>
              Vamos a configurarla de tal manera que vamos a tener las pesta√±as
              de JavaScript y la de la consola de output.
            </p>
            <img src="../images/regexp/jsoutput.png" id="img-jsoutput" alt="" />
            <h4>Horizontal tab \t üî≠</h4>
            <p>
              \t en min√∫scula se utiliza para a√±adir tabulaciones dentro de un
              texto.
            </p>
            <p>
              Si a√±adimos una tabulaci√≥n \t entre el Hola, y el ¬øQu√© tal? el
              resultado ser√° el siguiente:
            </p>
            <img src="../images/regexp/t.png" id="img-t" alt="" />
            <h4>New line \n üÜï</h4>
            <p>
              \n en min√∫scula se utiliza para a√±adir una new line (salto de
              l√≠nea) dentro de un texto.
            </p>
            <p>El resultado ser√° el siguiente:</p>
            <img src="../images/regexp/n.png" id="img-n" alt="" />
          </div>
        </section>
        <section id="reg-quanti">
          <h2>4. Quantifiers üèÅ</h2>
          <div id="reg-short">
            <h3>
              4.1 - 0 or more times (*), 1 or more times (+), 0 or 1 time (?) ‚òÅ
            </h3>
            <h4>¬øQu√© son los quantifiers/cuantificadores? ‚åõ</h4>
            <p>
              Los cuantificadores dentro de las expresiones regulares (regex)
              son caracteres especiales que se utilizan para especificar la
              cantidad de veces que un elemento debe coincidir en una cadena de
              texto.
            </p>
            <p class="recuadro">
              üí° Los cuantificadores permiten hacer que su patr√≥n regex sea m√°s
              flexible y conciso. Adem√°s, especifican con qu√© frecuencia debe
              coincidir una expresi√≥n regular o parte de ella.
            </p>
            <p>Bas√°ndonos sobre el siguiente texto:</p>
            <p>
              AB <br />
              A_B <br />
              A__B <br />
              A___B <br />
              A____B
            </p>
            <p>
              Con este patr√≥n, estamos buscando los que literalmente tengan A_B:
            </p>
            <img src="../images/regexp/q1.png" id="img-q1" alt="" />
            <p>
              Pero ¬øC√≥mo har√≠amos si quisi√©ramos seleccionar todos los elementos
              que tengan AB los que tengan barras bajas de por medio y los que
              no?
            </p>
            <h4>0 or more times * üïó</h4>
            <p>
              * define que el patr√≥n o la parte del patr√≥n definida debe
              coincidir cero o m√°s veces. Vamos a ver un ejemplo:
            </p>
            <p>
              Por ejemplo, A_*B buscar√° coincidencias con AB sin ninguna _ o con
              m√∫ltiples _ en una fila.
            </p>
            <img src="../images/regexp/q2.png" id="img-q2" alt="" />
            <p class="recuadro">
              üí° Si nos fijamos, estamos seleccionado todos los AB, ya que con
              el _* le estamos especificando que nos seleccion√© todos los
              elementos ya tenga 0, 1 o m√∫ltiples coincidencias.
            </p>
            <img src="../images/regexp/q3.png" id="img-q3" alt="" />
            <h4>0 or 1 time ? üïï</h4>
            <p>
              ? define que el patr√≥n o la parte del patr√≥n definida debe estar
              presente 1 vez o ninguna. Vamos a ver un ejemplo:
            </p>
            <img src="../images/regexp/q4.png" id="img-q4" alt="" />
          </div>
          <div id="reg-exact">
            <h3>
              4.2 - Exactly n times {n}, at least n times {n,} and from n to m
              times {n,m} üïõ
            </h3>
            <h4>Exactly n times {n} üïõ</h4>
            <p>
              {n} define que el patr√≥n o la parte del patr√≥n definida debe
              coincidir n veces. Vamos a ver un ejemplo:
            </p>
            <p>
              Con este patr√≥n A_{2}B, estamos buscando los casos que
              literalmente tengan literalmente dos __ entre AB:
            </p>
            <img src="../images/regexp/q5.png" id="img-q5" alt="" />
            <h4>At least n times {n,} üïï</h4>
            <p>
              {n,} define que el patr√≥n o la parte del patr√≥n definida debe
              coincidir n o m√°s veces. Vamos a ver un ejemplo:
            </p>
            <p>
              Con este patr√≥n A_{2,}B, estamos buscando los casos que
              literalmente tengan literalmente dos __ o m√°s _ entre AB:
            </p>
            <img src="../images/regexp/q6.png" id="img-q6" alt="" />
            <h4>From n to m times {n,m} üïñ</h4>
            <p>
              {n,m} define que el patr√≥n o la parte del patr√≥n definida debe
              coincidir dentro del rango de n veces a m veces. Vamos a ver un
              ejemplo:
            </p>
            <img src="../images/regexp/q7.png" id="img-q7" alt="" />
          </div>
          <div id="reg-grla">
            <h3>4.3 - Greedy/codicioso VS Lazy/Perezoso ü¶•</h3>
            <p>
              La principal diferencia entre "greedy" (codicioso) y "lazy"
              (perezoso) en el contexto de expresiones regulares es c√≥mo manejan
              las repeticiones. Estos t√©rminos se aplican a los cuantificadores,
              como *, +, ?, {n,m}, etc., y afectan la forma en que se realiza la
              coincidencia en el texto.
            </p>
            <h4>Greedy/Codicioso üí∞</h4>
            <p>
              Greedy = ‚ÄòCodicioso‚Äô intentar√° matchear la cadena m√°s larga
              posible. Es decir, si tiene varias opciones donde parar ir√° hasta
              la m√°s lejana ya que es codicioso y tiene muchas ganas de
              trabajar.
            </p>
            <p>Bas√°ndonos sobre el siguiente texto:</p>
            <p>stackoverflow</p>
            <p>
              Con greedy (el codicioso) llegaremos a la o m√°s lejana de las dos
              que tenemos:
            </p>
            <img src="../images/regexp/q8.png" id="img-q8" alt="" />
            <h4>Lazy/Perezoso ü¶•</h4>
            <p>
              Lazy = ‚ÄòPerezoso‚Äô intentar√° coger la cadena m√°s cercana posible.
              Es decir, si tiene varias opciones donde parar ir√° hasta la m√°s
              cercana ya que es perezoso y no tiene muchas ganas de trabajar.
            </p>
            <p>
              Con el lazy (el perezoso), en cambio, queremos acabar cuanto
              antes. Por lo que cogemos la cadena m√°s corta posible. Vamos a ver
              un ejemplo:
            </p>
            <img src="../images/regexp/q9.png" id="img-q9" alt="" />
          </div>
        </section>
        <section id="reg-anchors">
          <h2>5. Anchors üî±</h2>
          <div id="reg-stend">
            <h3>
              5.1 - Start at beginning of String (^) & end of String ($) ‚öì
            </h3>
            <p>
              Existen mecanismos, es decir ciertos caracteres ($ y ^) mediante a
              los cuales podemos comprobar/‚Äùanclar‚Äù si una cadena empieza o
              acaba por un patr√≥n. Os explicamos como funcionan.
            </p>
            <h4>Start at beginning of String ^ ‚öì</h4>
            <p>^ el patr√≥n empieza por‚Ä¶</p>
            <p>Bas√°ndonos sobre el siguiente texto:</p>
            <p>
              abc <br />
              babc <br />
              cabcde <br />
              ddeabc
            </p>
            <p>
              Si escribimos el patr√≥n abc, vemos que se matchear√°n todos los
              casos en los que abc est√© presente. Independientemente de si est√°
              al inicio, al final o en el centro de la cadena.
            </p>
            <img src="../images/regexp/a1.png" id="img-a1" alt="" />
            <p>
              En cambio, si queremos matchear solamente los casos que empiecen
              por abc , debemos de a√±adir el ^ antes del texto. Vamos a ver un
              ejemplo:
            </p>
            <img src="../images/regexp/a2.png" id="img-a2" alt="" />
            <h4>End of String $ üö¢</h4>
            <p>$ El patr√≥n acaba con‚Ä¶</p>
            <p>
              Si queremos seleccionar las cadenas de texto que acaban pro bc, el
              regex para hacer el match ser√≠a el siguiente:
            </p>
            <img src="../images/regexp/a3.png" id="img-a3" alt="" />
            <h4>Combinando ^ con $ üö¢‚öì</h4>
            <p>
              Existe tambi√©n la posibilidad de que $ y ^ convivan dentro de un
              mismo patr√≥n.
            </p>
            <p>
              Por ejemplo, el siguiente ejemplo solo matchear√° los casos en los
              que la l√≠nea empiece y acabe por abc:
            </p>
            <img src="../images/regexp/a4.png" id="img-a4" alt="" />
          </div>
          <div id="reg-wordbound">
            <h3>5.2 - Word buoundary \b & not word boundary \B üöù</h3>
            <h4>Word buoundary \b sin texto ‚öì</h4>
            <p>
              \b en min√∫scula y sin ir englobada sobre un texto (\bTEXT\b)
              representa un l√≠mite de palabra (word boundary). Es decir, act√∫a
              como un ancla que marca la posici√≥n entre caracteres de palabra
              (alfanum√©ricos) y caracteres que no son de palabra (como espacios,
              signos de puntuaci√≥n, etc.).
            </p>
            <p>
              Inicialmente, si utilizamos \b sin nada m√°s en el siguiente texto
              podemos observar que se selecciona el inicio y fin de cada una de
              las palabras.
            </p>
            <h4>Word buoundary \b con texto ‚öìüìã</h4>
            <p>
              \b en min√∫scula, representa un l√≠mite de palabra (word boundary)
              act√∫a como delimitador de palabras lo que nos permite delimitar
              una palabra de inicio a fin, evitando que se cuelen subcadenas de
              dentro de otras palabras m√°s largas. De tal forma que nos
              garantiza que estamos buscando palabras exactas en lugar de partes
              de palabras. Esto es especialmente √∫til en escenarios como la
              b√∫squeda y reemplazo de palabras en un texto.
            </p>
            <p class="recuadro">
              üí° Englobando una palabra con \b nos aseguramos que
              seleccionaremos √∫nica y exclusivamente las palabras contenidas
              entre las dos \bWORD\b de tal manera que solamente seleccionaremos
              las que empiecen y acaben de tal forma. Y no las que contengan
              dicha palabra.
            </p>
            <h4>Not word boundary \B caracteres de entre palabras üìñ</h4>
            <p>
              La secuencia de escape \B matchear√° a cualquier car√°cter siempre
              que no este no se encuentre en el l√≠mite de palabra. En otras
              palabras, coincide con posiciones dentro de palabras o entre
              caracteres que son todos alfanum√©ricos.
            </p>
          </div>
        </section>
        <section id="reg-alternation">
          <h2>6. Alternation ‚ö°</h2>
          <div>
            <h3>6.1 - Alternation |</h3>
            <p>
              | la alternaci√≥n dentro de las expresiones regulares se refiere a
              la capacidad de especificar m√∫ltiples alternativas sobre el patr√≥n
              que busca en una cadena de texto. Para ello, se utiliza el
              operador de barra vertical | separando cada una de las
              alternativas.
            </p>
            <h3>
              6.2 - Match y match matchea la expresi√≥n completa o sino no se
              matchea üéØ
            </h3>
            <p>
              La construcci√≥n (?(exp)yes|no) es parte de las expresiones
              regulares condicionales y permite definir un patr√≥n que coincide
              con "yes" si la expresi√≥n condicional exp es verdadera y con "no"
              si es falsa. Aqu√≠ tienes un ejemplo de c√≥mo usar esta construcci√≥n
              en una expresi√≥n regular:
            </p>
            <img src="../images/regexp/alt1.png" id="img-alt1" alt="" />
          </div>
        </section>
        <section id="reg-gruprarus">
          <h2>7. Groups rarunos üê∏</h2>
          <div>
            <ol>
              <li>
                \L$1: Todas las palabras en el grupo coincidente se cambiar√°n a
                min√∫sculas.
              </li>
              <li>
                \l$1: La primera letra en el grupo coincidente estar√° en
                min√∫scula, el resto permanecer√° sin cambios.
              </li>
              <li>
                \U$1: Todas las palabras en el grupo coincidente se cambiar√°n a
                may√∫sculas.
              </li>
              <li>
                \u$1: La primera letra en el grupo coincidente estar√° en
                may√∫scula, el resto permanecer√° sin cambios.
              </li>
            </ol>
          </div>
        </section>
        <section>
          <h3>ü•©Chuletita Cheat sheetü•©</h3>
          <div>
            <img src="../images/regexp/chuleta.png" id="img-chuleta" alt="" />
          </div>
          <h2 id="reg-webrecom">ü§ìWebs recomendadasü§ì</h2>
          <div></div>
        </section>
      </article>
    </main>
    <footer>
      StudyWeb ¬© 2024 Todos los derechos reservados. |
      <a href="../assets/other/politicaprivacidad.html"
        >Pol√≠tica de privacidad</a
      >
      | <a href="#">T√©rminos y condiciones</a> | <a href="#">Contacto</a>
    </footer>
  </body>
</html>
